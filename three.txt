import cv2
import time
import pytesseract
from datetime import datetime
from picamera2 import Picamera2
from RPLCD.gpio import CharLCD
import RPi.GPIO as GPIO
from csv import writer
import numpy as np

# --- Configuration ---
debug = True
MAX_RETRIES = 3

# GPIO setup
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)

# LCD 1602A setup (without I2C)
lcd = CharLCD(
    numbering_mode=GPIO.BCM,
    cols=16,
    rows=2,
    pin_rs=7,
    pin_e=8,
    pins_data=[25, 24, 23, 12]
)

# Initialize PiCamera2
picam2 = Picamera2()
picam2.configure(picam2.create_preview_configuration(main={"size": (1280, 720)}))
picam2.start()

def capture_image():
    frame = picam2.capture_array()
    return cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)

def extract_plate(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blur = cv2.bilateralFilter(gray, 11, 90, 90)
    edges = cv2.Canny(blur, 30, 200)

    contours, _ = cv2.findContours(edges, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    for contour in sorted(contours, key=cv2.contourArea, reverse=True)[:30]:
        peri = cv2.arcLength(contour, True)
        approx = cv2.approxPolyDP(contour, 0.02 * peri, True)
        if len(approx) == 4:
            x, y, w, h = cv2.boundingRect(approx)
            aspect_ratio = w / float(h)
            if 2 < aspect_ratio < 6:
                return image[y:y+h, x:x+w]
    return None

def recognize_plate(plate_img):
    try:
        plate_img = cv2.resize(plate_img, (400, 100))
        gray = cv2.cvtColor(plate_img, cv2.COLOR_BGR2GRAY)
        gray = cv2.bilateralFilter(gray, 11, 17, 17)
        gray = cv2.equalizeHist(gray)

        thresh = cv2.adaptiveThreshold(
            gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
            cv2.THRESH_BINARY_INV, 19, 9
        )

        if debug:
            cv2.imshow("Plate", plate_img)
            cv2.imshow("Threshold", thresh)
            cv2.waitKey(1000)
            cv2.destroyAllWindows()

        config = "--psm 7 -c tessedit_char_whitelist=ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        text = pytesseract.image_to_string(thresh, config=config)
        text = ''.join(char for char in text if char.isalnum())
        return text.strip()
    except Exception as e:
        if debug:
            print("[ERROR] OCR failed:", e)
        return ""

def log_plate(text):
    with open("plate_log.csv", "a", newline="") as file:
        csv_writer = writer(file)
        csv_writer.writerow([datetime.now().strftime("%Y-%m-%d %H:%M:%S"), text])

def main():
    lcd.clear()
    lcd.write_string("Capturing...")
    print("[INFO] Capturing image...")

    time.sleep(1)
    image = capture_image()

    lcd.clear()
    lcd.write_string("Processing...")
    print("[INFO] Processing image...")

    plate = None
    for attempt in range(MAX_RETRIES):
        plate = extract_plate(image)
        if plate is not None:
            break
        time.sleep(0.5)

    if plate is not None:
        text = recognize_plate(plate)
        if text:
            lcd.clear()
            lcd.write_string("Loading...")
            print(f"[INFO] Plate text: {text}")
            log_plate(text)
            time.sleep(1)
            lcd.clear()
            lcd.write_string(text[:16])
        else:
            lcd.clear()
            lcd.write_string("Plate Not Clear")
            print("[WARN] Text not recognized.")
    else:
        lcd.clear()
        lcd.write_string("No Plate Found")
        print("[WARN] No plate region found.")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        GPIO.cleanup()
        lcd.clear()
        lcd.write_string("Stopped")
        print("[INFO] Stopped by user.")
///////////////////////////////////////////////
# -*- coding: utf-8 -*-
import cv2
import numpy as np
import pytesseract
import RPi.GPIO as GPIO
import time
from picamera2 import Picamera2

# GPIO Setup
GPIO.setwarnings(False)  # Disable warnings
GPIO.setmode(GPIO.BCM)

BUZZ_PIN = 18
BARRIER_PIN = 17
GPIO.setup(BUZZ_PIN, GPIO.OUT)
GPIO.setup(BARRIER_PIN, GPIO.OUT)

# Initialize Picamera2
picam2 = Picamera2()
picam2.configure(picam2.create_preview_configuration(main={"size": (1280, 720)}))
picam2.start()

def capture_image():
    """Capture an image using Picamera2 and return as an OpenCV frame."""
    frame = picam2.capture_array()
    return cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)

def plate_extraction(image):
    """Extract license plate from the given image."""
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blur = cv2.bilateralFilter(gray, 11, 90, 90)
    edges = cv2.Canny(blur, 30, 200)

    cnts, _ = cv2.findContours(edges, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    cnts = sorted(cnts, key=cv2.contourArea, reverse=True)[:30]

    for c in cnts:
        perimeter = cv2.arcLength(c, True)
        approx = cv2.approxPolyDP(c, 0.02 * perimeter, True)
        if len(approx) == 4:
            x, y, w, h = cv2.boundingRect(c)
            return image[y:y+h, x:x+w]
    return None

def ocr_processing(plate):
    """Recognize text from the extracted plate."""
    text = pytesseract.image_to_string(plate, config='--psm 7')
    return ''.join(e for e in text if e.isalnum())

def check_database(plate_text):
    """Check if the plate number exists in the database."""
    try:
        with open('Database.txt', 'r') as f:
            return any(plate_text in line for line in f)
    except FileNotFoundError:
        print("[ERROR] Database file not found!")
        return False

def control_barrier(state):
    """Open or close the barrier using GPIO."""
    GPIO.output(BARRIER_PIN, state)
    time.sleep(1) if state else time.sleep(0.5)

def main():
    print("?? ANPR System Started... Press 'q' to Quit.")

    while True:
        frame = capture_image()
        plate = plate_extraction(frame)

        if plate is not None:
            plate_text = ocr_processing(plate)

            if plate_text:
                print(f"Detected Plate: {plate_text}", end=' ')
                if check_database(plate_text):
                    print("[REGISTERED] ? Opening Barrier...")
                    GPIO.output(BUZZ_PIN, GPIO.HIGH)
                    control_barrier(GPIO.HIGH)
                    time.sleep(0.5)
                    GPIO.output(BUZZ_PIN, GPIO.LOW)
                    control_barrier(GPIO.LOW)
                else:
                    print("[UNREGISTERED] ? Access Denied!")
                    GPIO.output(BUZZ_PIN, GPIO.HIGH)
                    time.sleep(0.2)
                    GPIO.output(BUZZ_PIN, GPIO.LOW)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    print("Shutting Down...")
    picam2.stop()
    GPIO.cleanup()

if __name__ == "__main__":
    main()
///////////////////////////
from RPLCD.gpio import CharLCD
import RPi.GPIO as GPIO
from time import sleep

GPIO.setwarnings(False)

lcd = CharLCD(
    numbering_mode=GPIO.BCM,
    cols=16, rows=2,
    pin_rs=7, pin_e=8,
    pins_data=[25, 24, 23, 12]
)

lcd.clear()
lcd.write_string("Hello World!")
sleep(5)
lcd.clear()

