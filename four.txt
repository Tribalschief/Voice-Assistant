import cv2
import numpy as np
import pytesseract
import RPi.GPIO as GPIO
import time
from picamera2 import Picamera2
from RPLCD.gpio import CharLCD
import re # Import regex module for more flexible cleaning

# --- GPIO Setup ---
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)

BUZZ_PIN = 18
BARRIER_PIN = 17
GPIO.setup(BUZZ_PIN, GPIO.OUT)
GPIO.setup(BARRIER_PIN, GPIO.OUT)
GPIO.output(BARRIER_PIN, GPIO.LOW) # Ensure barrier is closed at start
GPIO.output(BUZZ_PIN, GPIO.LOW)   # Ensure buzzer is off at start

# --- LCD 1602A Setup (Without I2C) ---
# !! DOUBLE CHECK THESE PINS MATCH YOUR WIRING !!
try:
    lcd = CharLCD(
        numbering_mode=GPIO.BCM,
        cols=16,
        rows=2,
        pin_rs=7,
        pin_e=8,
        pins_data=[25, 24, 23, 12],
        charmap='A00', # Standard European character map (only affects LCD display, not OCR)
        auto_linebreaks=True
    )
    lcd.clear() # Clear display on startup
    lcd_ready = True
    print("LCD Initialized Successfully.")
except Exception as e:
    print(f"[ERROR] Failed to initialize LCD: {e}")
    print("Check GPIO connections and RPLCD installation.")
    lcd_ready = False
    # Define dummy lcd functions if init fails to avoid errors later
    class DummyLCD:
        def write_string(self, text): pass
        def clear(self): pass
        def cursor_pos(self, pos): pass
    lcd = DummyLCD()


# --- PiCamera2 Setup ---
picam2 = Picamera2()
# Consider image size trade-offs:
# Smaller (e.g., 640, 480): Faster processing, lower resolution for distant plates.
# Larger (e.g., 1280, 720): Slower processing, better detail. (1024, 576) is a good compromise.
picam2.configure(picam2.create_preview_configuration(main={"size": (1024, 576)}))
picam2.start()
# Allow camera sensor to settle
time.sleep(2.0)
print("Camera Initialized.")


# --- Helper Function for Perspective Transform ---
# (Keep this function as is, it's standard geometry)
def order_points(pts):
    rect = np.zeros((4, 2), dtype="float32")
    s = pts.sum(axis=1)
    rect[0] = pts[np.argmin(s)]
    rect[2] = pts[np.argmax(s)]
    diff = np.diff(pts, axis=1)
    rect[1] = pts[np.argmin(diff)]
    rect[3] = pts[np.argmax(diff)]
    return rect

def perspective_transform(image, pts):
    rect = order_points(pts)
    (tl, tr, br, bl) = rect
    widthA = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))
    widthB = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))
    maxWidth = max(int(widthA), int(widthB))
    heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))
    heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))
    maxHeight = max(int(heightA), int(heightB))

    # Make sure dimensions are valid before creating dst array
    if maxWidth <= 0 or maxHeight <= 0:
        print("[WARN] Invalid dimensions calculated for perspective transform.")
        return None # Return None if dimensions are invalid

    dst = np.array([
        [0, 0],
        [maxWidth - 1, 0],
        [maxWidth - 1, maxHeight - 1],
        [0, maxHeight - 1]], dtype="float32")

    M = cv2.getPerspectiveTransform(rect, dst)
    warped = cv2.warpPerspective(image, M, (maxWidth, maxHeight))
    return warped

# --- Image Processing Functions ---
def capture_image():
    # Capture frame as numpy array BGR format
    frame = picam2.capture_array("main")
    # Picamera2 usually gives RGB, OpenCV expects BGR.
    # Double-check this: If colors look swapped (blue/red), uncomment the line below.
    frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR) # UNCOMMENTED based on common picam2 usage
    return frame

def plate_extraction(image):
    if image is None or image.size == 0: return None # Add check for valid input image

    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blur = cv2.bilateralFilter(gray, 11, 17, 17)
    edges = cv2.Canny(blur, 30, 180) # Wider range might catch plates in varying light
                                     # TUNE THIS: Low threshold (30) / High threshold (180)

    cnts, _ = cv2.findContours(edges.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    cnts = sorted(cnts, key=cv2.contourArea, reverse=True)[:10] # Check top 10

    plate_contour = None
    for c in cnts:
        perimeter = cv2.arcLength(c, True)
        epsilon = 0.018 # TUNE THIS: Approximation accuracy
        approx = cv2.approxPolyDP(c, epsilon * perimeter, True)

        if len(approx) == 4:
            # Basic Aspect Ratio and Area Check (optional but recommended)
            (x, y, w, h) = cv2.boundingRect(approx)
            aspect_ratio = w / float(h) if h > 0 else 0
            area = cv2.contourArea(approx)

            # Adjust these min/max values based on expected plate size/distance in your setup
            min_aspect_ratio = 1.5
            max_aspect_ratio = 5.5
            min_area = 400 # Minimum pixel area to reduce noise

            if aspect_ratio >= min_aspect_ratio and aspect_ratio <= max_aspect_ratio and area > min_area:
                plate_contour = approx
                break # Found a plausible plate

    if plate_contour is None:
        return None
    else:
        pts = plate_contour.reshape(4, 2)
        warped_plate = perspective_transform(image, pts) # Use color image

        if warped_plate is None or warped_plate.size == 0:
             return None

        return warped_plate

def ocr_processing(plate_image):
    if plate_image is None or plate_image.size == 0:
        return ""

    target_height = 60
    aspect_ratio = plate_image.shape[1] / plate_image.shape[0]
    target_width = int(target_height * aspect_ratio)
    if target_width > 0 and target_height > 0:
         try:
            plate_image_resized = cv2.resize(plate_image, (target_width, target_height), interpolation=cv2.INTER_LANCZOS4)
         except cv2.error:
             plate_image_resized = plate_image # Use original if resize fails
    else:
        plate_image_resized = plate_image # Use original if dims invalid

    gray_plate = cv2.cvtColor(plate_image_resized, cv2.COLOR_BGR2GRAY)
    # No blur initially often works ok with adaptive threshold
    # blurred_plate = cv2.GaussianBlur(gray_plate, (3, 3), 0)

    binary_plate = cv2.adaptiveThreshold(
        gray_plate, # Use gray directly
        255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY_INV,
        19, # TUNE THIS: Block Size (try larger if chars are thick)
        9   # TUNE THIS: Constant C (increase if too much noise included, decrease if chars broken)
    )

    # --- Tesseract OCR ---
    # TUNE THIS: PSM mode (7: single line, 8: single word, 6: uniform block, 11: sparse)
    custom_config = r'--oem 3 --psm 7'

    try:
        text = pytesseract.image_to_string(binary_plate, config=custom_config)

        # --- OCR Cleanup ---
        cleaned_text = text.strip()
        # Basic alphanumeric cleanup + uppercase
        cleaned_text = ''.join(filter(str.isalnum, cleaned_text)).upper()
        # Example more advanced cleanup (remove leading/trailing non-letters/numbers)
        # cleaned_text = re.sub(r'^[^A-Z0-9]+|[^A-Z0-9]+$', '', cleaned_text)

        # TUNE THIS: Minimum plate length
        if len(cleaned_text) < 4:
            return ""

        return cleaned_text
    except pytesseract.TesseractNotFoundError:
        print("[ERROR] Tesseract is not installed or not in your PATH.")
        return ""
    except Exception as e:
        print(f"[ERROR] OCR failed: {e}")
        return ""


def check_database(plate_text):
    if not plate_text:
        return False
    try:
        with open('Database.txt', 'r') as f:
            database_plates = {line.strip().upper() for line in f if line.strip()}
            return plate_text in database_plates
    except FileNotFoundError:
        print("[ERROR] Database.txt file not found!")
        try:
             with open('Database.txt', 'w') as f: pass # Create empty
             print("[WARN] Created empty Database.txt")
        except IOError: print("[ERROR] Could not create Database.txt")
        return False
    except Exception as e:
        print(f"[ERROR] Error reading database: {e}")
        return False


def control_barrier(state):
    if state in [GPIO.HIGH, GPIO.LOW]:
        GPIO.output(BARRIER_PIN, state)
    else:
        print(f"[WARN] Invalid state '{state}' for barrier control.")


def lcd_display(line1, line2=""):
    if not lcd_ready: return
    try:
        lcd.clear()
        lcd.cursor_pos = (0, 0)
        lcd.write_string(str(line1)[:16])
        if line2:
            lcd.cursor_pos = (1, 0)
            lcd.write_string(str(line2)[:16])
    except Exception as e:
        print(f"[ERROR] Failed to write to LCD: {e}")


# ========================
#        MAIN FUNCTION
# ========================
def main():
    print("ðŸš— ANPR System Started...")
    print("Press Ctrl+C in this terminal to Quit.")
    lcd_display("ANPR System", "Initializing...")
    time.sleep(1)
    lcd_display("ANPR System", "Ready")

    last_detected_plate = ""     # Stores the most recent OCR result string
    last_processed_plate = ""  # << NEW: Stores the plate that triggered the last action
    last_detection_time = 0    # Timestamp of the last time *any* plate was detected by OCR
    last_process_time = 0      # << NEW: Timestamp when the last action (grant/deny) occurred
    # TUNE THESE: Delays and Timeouts
    debounce_display_time = 1  # Seconds before showing the same detected plate again in console/LCD
    process_cooldown = 10      # << NEW: Seconds to wait *after* an action before processing ANY plate again
    reset_timeout = 15         # << NEW: Seconds without ANY plate detection before resetting 'last_processed_plate'

    try:
        while True:
            current_time = time.time()
            frame = capture_image()
            if frame is None:
                print("[WARN] Failed to capture frame.")
                time.sleep(0.5)
                continue

            plate_found = False # Flag to track if *any* plate contour was found this frame
            extracted_plate_img = plate_extraction(frame)

            # --- Process only if a plate region was extracted ---
            if extracted_plate_img is not None:
                plate_found = True
                plate_text = ocr_processing(extracted_plate_img)

                # --- Process only if OCR returned a valid-looking plate ---
                if plate_text:
                    last_detection_time = current_time # Update time whenever OCR finds something

                    # --- Condition 1: Has enough time passed since the *last action*? ---
                    if current_time - last_process_time > process_cooldown:

                        # --- Condition 2: Is this plate different from the one last *processed*? ---
                        if plate_text != last_processed_plate:

                            # --- Condition 3 (Display Debounce): Is it different from last *detection* OR enough time passed? ---
                            # This prevents console/LCD spam if OCR flickers briefly before stabilizing on the NEW plate.
                            if plate_text != last_detected_plate or (current_time - last_detection_time > debounce_display_time):
                                print(f"Detected Plate: '{plate_text}'", end=' ')
                                lcd_display("Plate: " + plate_text, "Checking...")
                                # Update last_detected_plate *only* when we display/log it
                                last_detected_plate = plate_text
                                # NOTE: last_detection_time was already updated above

                                # --- Perform the actual Database Check and Actions ---
                                if check_database(plate_text):
                                    print("[REGISTERED] âœ… Access Granted!")
                                    lcd_display(plate_text, "Access Granted")
                                    GPIO.output(BUZZ_PIN, GPIO.HIGH)
                                    control_barrier(GPIO.HIGH)      # Open
                                    time.sleep(0.5)                 # Buzzer on duration
                                    GPIO.output(BUZZ_PIN, GPIO.LOW)
                                    time.sleep(4)                   # Barrier open duration << INCREASED?
                                    control_barrier(GPIO.LOW)       # Close
                                    print(f"-> Processed '{plate_text}'. Starting cooldown.")

                                else: # Access Denied
                                    print("[UNREGISTERED] âŒ Access Denied!")
                                    lcd_display(plate_text, "Access Denied")
                                    # Short buzzes for denial
                                    for _ in range(3):
                                        GPIO.output(BUZZ_PIN, GPIO.HIGH)
                                        time.sleep(0.1)
                                        GPIO.output(BUZZ_PIN, GPIO.LOW)
                                        time.sleep(0.1)
                                    time.sleep(1.5) # Show denied message
                                    print(f"-> Processed '{plate_text}'. Starting cooldown.")

                                # === IMPORTANT: Mark plate as processed and record time ===
                                last_processed_plate = plate_text
                                last_process_time = current_time # Start cooldown timer
                                last_detected_plate = "" # Reset last detected to force redisplay if seen again after cooldown

                                # --- Update LCD to Ready after action ---
                                lcd_display("ANPR System", "Ready")
                                time.sleep(0.5) # Small pause before scanning again

                            # Else (condition 3 fail): Plate is new compared to last *processed*,
                            # but same as last *detected* within display debounce time. Do nothing this cycle.
                            # Let OCR stabilize or wait for display debounce timeout.

                        # Else (condition 2 fail): Same plate as last processed. Ignore during cooldown.
                        else:
                             # Optional: Print statement for debugging, can be removed later
                             # if plate_text != last_detected_plate: # Only print if OCR result differs slightly
                             #    print(f"Ignoring '{plate_text}' (matches last processed: '{last_processed_plate}')")
                             #    last_detected_plate = plate_text # Update detected even if ignored
                             pass # Silently ignore

                    # Else (condition 1 fail): Still within the cooldown period after last action.
                    else:
                        # Update last detected plate if it changed slightly, even during cooldown
                        # if plate_text != last_detected_plate:
                        #    last_detected_plate = plate_text
                        pass # Don't process anything, still cooling down

                # Else (OCR returned empty string): No valid text found on the potential plate image.
                # Keep last_detection_time updated from when the *contour* was found? Or only when OCR is non-empty?
                # Let's update only on non-empty OCR (as done above).
                pass

            # --- End of processing extracted plate ---


            # --- Reset Logic: If NO plate contour found for a while, reset the 'processed' lock ---
            if not plate_found:
                # Check if enough time has passed since the last time *any* plate was *detected*
                if current_time - last_detection_time > reset_timeout:
                    if last_processed_plate != "": # Only reset if there's something to reset
                        print(f"\nNo plate detected for {reset_timeout}s. Resetting lock for '{last_processed_plate}'.")
                        last_processed_plate = ""
                        last_detected_plate = "" # Also clear last detected
                        lcd_display("ANPR System", "Ready") # Ensure LCD is Ready
                        # Reset last_detection_time to prevent immediate re-resetting
                        # Set it far in the past, or to current time? Setting to current is simpler.
                        last_detection_time = current_time # Pretend detection just happened for timeout purpose


            # --- Small delay in main loop ---
            time.sleep(0.1) # Main loop sleep


    except KeyboardInterrupt:
        print("\nðŸ›‘ Ctrl+C detected. Shutting Down...")
    finally:
        print("Cleaning up resources...")
        # Ensure barrier is closed and buzzer off
        GPIO.output(BARRIER_PIN, GPIO.LOW)
        GPIO.output(BUZZ_PIN, GPIO.LOW)
        lcd_display("System Stopped", "")
        time.sleep(1)
        if lcd_ready:
             try: lcd.clear()
             except Exception: pass
        picam2.stop()
        print("Camera stopped.")
        GPIO.cleanup()
        print("GPIO Cleaned Up. Exiting.")


# --- Initialization Checks ---
if __name__ == "__main__":
    try:
        tesseract_version = pytesseract.get_tesseract_version()
        print(f"Tesseract version: {tesseract_version}")
    except pytesseract.TesseractNotFoundError:
        # (Error message as before) ...
        exit(1)

    try:
        with open('Database.txt', 'r') as f:
             print("Database.txt found.")
    except FileNotFoundError:
         print("[WARNING] Database.txt not found.")
         try:
             with open('Database.txt', 'w') as f: print("  An empty Database.txt created.")
         except IOError as e: print(f"[ERROR] Could not create Database.txt: {e}")

    # --- Start Main Application ---
    main()
///////////////////////////

import cv2
import numpy as np
import pytesseract
import RPi.GPIO as GPIO
import time
from picamera2 import Picamera2
from RPLCD.gpio import CharLCD
import re # Import regex module for more flexible cleaning
import os # For creating debug directory

# ==================================
#        CONFIGURATION & TUNING
# ==================================
DEBUG_MODE = True            # Set to True to save intermediate images for debugging
DEBUG_IMG_PATH = "debug_images" # Folder to save debug images

# --- Camera ---
IMG_WIDTH = 1024
IMG_HEIGHT = 576

# --- Plate Extraction Tuning ---
CANNY_LOW_THRESH = 50       # Lower edge detection threshold (adjust based on lighting/contrast)
CANNY_HIGH_THRESH = 180      # Higher edge detection threshold
CONTOUR_APPROX_FACTOR = 0.02 # Contour approximation accuracy (smaller = more precise, larger = more lenient)
MIN_PLATE_AREA = 500        # Minimum pixel area for a contour to be considered a plate
MIN_ASPECT_RATIO = 1.8       # Minimum width/height ratio for a plate
MAX_ASPECT_RATIO = 5.5       # Maximum width/height ratio for a plate

# --- OCR Preprocessing Tuning ---
OCR_RESIZE_HEIGHT = 60       # Target height for the plate image before OCR
# Thresholding method ('ADAPTIVE' or 'OTSU')
THRESHOLD_METHOD = 'ADAPTIVE'
# Adaptive Threshold Params (if THRESHOLD_METHOD = 'ADAPTIVE')
ADAPT_THRESH_BLOCK_SIZE = 19 # Size of the neighborhood area (MUST be odd)
ADAPT_THRESH_C = 9           # Constant subtracted from the mean
# Morphology (Optional - uncomment and tune kernel size if needed)
# MORPH_OPEN_KERNEL = (3, 3) # Kernel size for MORPH_OPEN (removes small noise)
# MORPH_CLOSE_KERNEL = (3, 3)# Kernel size for MORPH_CLOSE (fills small gaps)

# --- Tesseract Tuning ---
TESS_LANG = 'eng'            # Language model for Tesseract
TESS_OEM = 3                 # OCR Engine Mode (3 is default LSTM)
TESS_PSM = '7'               # Page Segmentation Mode (7=single line, 6=block, 8=word, 13=raw line)
# Whitelist specific characters (HIGHLY RECOMMENDED if format is known)
# Example: UK plates (Letters A-Z, Numbers 0-9)
TESS_WHITELIST = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
# TESS_WHITELIST = "" # Leave empty to allow all characters

# --- OCR Post-Processing / Validation ---
MIN_PLATE_LENGTH = 5         # Minimum number of characters for a valid plate
# Regex pattern for expected plate format (Optional but recommended)
# Example: UK Format (2 letters, 2 numbers, 3 letters)
# EXPECTED_PLATE_PATTERN = r"^[A-Z]{2}[0-9]{2}[A-Z]{3}$"
EXPECTED_PLATE_PATTERN = "" # Leave empty to skip regex validation

# --- Main Loop Timing ---
PROCESS_COOLDOWN = 8       # Seconds to wait after an action (grant/deny) before processing ANY plate again
RESET_TIMEOUT = 15         # Seconds without ANY plate detection before resetting 'last_processed_plate'

# --- GPIO Pins ---
BUZZ_PIN = 18
BARRIER_PIN = 17
# LCD Pins (!! DOUBLE CHECK THESE !!)
LCD_RS = 7
LCD_E  = 8
LCD_D4 = 25
LCD_D5 = 24
LCD_D6 = 23
LCD_D7 = 12
# ==================================

# --- Create Debug Directory ---
if DEBUG_MODE and not os.path.exists(DEBUG_IMG_PATH):
    try:
        os.makedirs(DEBUG_IMG_PATH)
        print(f"Created debug directory: {DEBUG_IMG_PATH}")
    except OSError as e:
        print(f"[ERROR] Could not create debug directory '{DEBUG_IMG_PATH}': {e}")
        DEBUG_MODE = False # Disable debug if directory fails

# --- GPIO Setup ---
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)
GPIO.setup(BUZZ_PIN, GPIO.OUT, initial=GPIO.LOW)
GPIO.setup(BARRIER_PIN, GPIO.OUT, initial=GPIO.LOW)

# --- LCD 1602A Setup ---
try:
    lcd = CharLCD(
        numbering_mode=GPIO.BCM,
        cols=16, rows=2,
        pin_rs=LCD_RS, pin_e=LCD_E, pins_data=[LCD_D4, LCD_D5, LCD_D6, LCD_D7],
        charmap='A00', auto_linebreaks=True
    )
    lcd.clear()
    lcd_ready = True
    print("LCD Initialized Successfully.")
except Exception as e:
    print(f"[ERROR] Failed to initialize LCD: {e}")
    lcd_ready = False
    class DummyLCD: # Define dummy functions if init fails
        def write_string(self, text): pass
        def clear(self): pass
        def cursor_pos(self, pos): pass
    lcd = DummyLCD()

# --- PiCamera2 Setup ---
try:
    picam2 = Picamera2()
    config = picam2.create_preview_configuration(main={"size": (IMG_WIDTH, IMG_HEIGHT)})
    picam2.configure(config)
    picam2.start()
    time.sleep(2.0) # Allow sensor to settle
    print("Camera Initialized.")
except Exception as e:
    print(f"[ERROR] Failed to initialize Camera: {e}")
    # Consider exiting if camera fails
    exit(1)

# --- Helper Function for Perspective Transform (Unchanged) ---
def order_points(pts):
    rect = np.zeros((4, 2), dtype="float32")
    s = pts.sum(axis=1)
    rect[0] = pts[np.argmin(s)]
    rect[2] = pts[np.argmax(s)]
    diff = np.diff(pts, axis=1)
    rect[1] = pts[np.argmin(diff)]
    rect[3] = pts[np.argmax(diff)]
    return rect

def perspective_transform(image, pts):
    rect = order_points(pts)
    (tl, tr, br, bl) = rect
    widthA = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))
    widthB = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))
    maxWidth = max(int(widthA), int(widthB))
    heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))
    heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))
    maxHeight = max(int(heightA), int(heightB))
    if maxWidth <= 0 or maxHeight <= 0: return None
    dst = np.array([
        [0, 0], [maxWidth - 1, 0],
        [maxWidth - 1, maxHeight - 1], [0, maxHeight - 1]], dtype="float32")
    M = cv2.getPerspectiveTransform(rect, dst)
    warped = cv2.warpPerspective(image, M, (maxWidth, maxHeight))
    return warped

# --- Image Processing Functions ---
def capture_image():
    try:
        frame = picam2.capture_array("main")
        # Picamera2 often gives RGB/RGBA, OpenCV expects BGR
        if frame.shape[2] == 4: # Handle RGBA if present
            frame = cv2.cvtColor(frame, cv2.COLOR_RGBA2BGR)
        else:
            frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
        return frame
    except Exception as e:
        print(f"[ERROR] Failed during image capture: {e}")
        return None

def plate_extraction(image):
    """Finds potential license plate contours and returns the warped perspective image."""
    if image is None or image.size == 0: return None

    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blur = cv2.bilateralFilter(gray, 11, 17, 17) # Good for edge preservation
    edges = cv2.Canny(blur, CANNY_LOW_THRESH, CANNY_HIGH_THRESH)

    if DEBUG_MODE:
        ts = int(time.time())
        cv2.imwrite(os.path.join(DEBUG_IMG_PATH, f"{ts}_01_edges.png"), edges)

    cnts, _ = cv2.findContours(edges.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    cnts = sorted(cnts, key=cv2.contourArea, reverse=True)[:10]

    plate_contour = None
    for c in cnts:
        perimeter = cv2.arcLength(c, True)
        approx = cv2.approxPolyDP(c, CONTOUR_APPROX_FACTOR * perimeter, True)

        if len(approx) == 4:
            (x, y, w, h) = cv2.boundingRect(approx)
            aspect_ratio = w / float(h) if h > 0 else 0
            area = cv2.contourArea(approx)

            if MIN_PLATE_AREA < area and MIN_ASPECT_RATIO < aspect_ratio < MAX_ASPECT_RATIO:
                plate_contour = approx
                if DEBUG_MODE:
                     # Draw contour on original for debugging
                     debug_frame = image.copy()
                     cv2.drawContours(debug_frame, [plate_contour], -1, (0, 255, 0), 2)
                     cv2.imwrite(os.path.join(DEBUG_IMG_PATH, f"{ts}_02_contour_found.png"), debug_frame)
                break

    if plate_contour is None:
        return None
    else:
        pts = plate_contour.reshape(4, 2)
        warped_plate = perspective_transform(gray, pts) # Use gray image for transform - sometimes better contrast

        if warped_plate is None or warped_plate.size == 0: return None

        if DEBUG_MODE:
            cv2.imwrite(os.path.join(DEBUG_IMG_PATH, f"{ts}_03_warped_plate.png"), warped_plate)

        return warped_plate


def ocr_processing(plate_image_gray):
    """Performs OCR on the extracted grayscale plate image."""
    if plate_image_gray is None or plate_image_gray.size == 0:
        return ""

    # --- Preprocessing ---
    # Resize (optional but can help consistency)
    try:
        h, w = plate_image_gray.shape[:2]
        aspect_ratio = w / h
        target_width = int(OCR_RESIZE_HEIGHT * aspect_ratio)
        if target_width > 0:
            plate_image_resized = cv2.resize(plate_image_gray, (target_width, OCR_RESIZE_HEIGHT), interpolation=cv2.INTER_LANCZOS4)
        else:
            plate_image_resized = plate_image_gray
    except Exception as e:
        print(f"[WARN] Resizing failed: {e}. Using original.")
        plate_image_resized = plate_image_gray

    # Thresholding
    if THRESHOLD_METHOD == 'ADAPTIVE':
        binary_plate = cv2.adaptiveThreshold(
            plate_image_resized, 255,
            cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV,
            ADAPT_THRESH_BLOCK_SIZE, ADAPT_THRESH_C
        )
    elif THRESHOLD_METHOD == 'OTSU':
        # Otsu often works better with slight blurring first
        blurred = cv2.GaussianBlur(plate_image_resized, (5, 5), 0)
        _, binary_plate = cv2.threshold(blurred, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
    else: # Default to adaptive if invalid method specified
         binary_plate = cv2.adaptiveThreshold(
            plate_image_resized, 255,
            cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV,
            ADAPT_THRESH_BLOCK_SIZE, ADAPT_THRESH_C
         )

    # Optional Morphology (Uncomment and tune if needed)
    # if 'MORPH_OPEN_KERNEL' in globals():
    #     kernel_open = np.ones(MORPH_OPEN_KERNEL, np.uint8)
    #     binary_plate = cv2.morphologyEx(binary_plate, cv2.MORPH_OPEN, kernel_open)
    # if 'MORPH_CLOSE_KERNEL' in globals():
    #     kernel_close = np.ones(MORPH_CLOSE_KERNEL, np.uint8)
    #     binary_plate = cv2.morphologyEx(binary_plate, cv2.MORPH_CLOSE, kernel_close)

    if DEBUG_MODE:
        ts = int(time.time())
        cv2.imwrite(os.path.join(DEBUG_IMG_PATH, f"{ts}_04_binary_plate.png"), binary_plate)

    # --- Tesseract OCR ---
    custom_config = f'--oem {TESS_OEM} --psm {TESS_PSM} -l {TESS_LANG}'
    if TESS_WHITELIST:
        custom_config += f' -c tessedit_char_whitelist={TESS_WHITELIST}'

    try:
        raw_text = pytesseract.image_to_string(binary_plate, config=custom_config)
        if DEBUG_MODE:
            print(f"  Raw Tesseract Output: '{raw_text.strip()}'")

        # --- OCR Cleanup & Validation ---
        # 1. Basic cleanup: Remove whitespace, convert to uppercase
        cleaned_text = ''.join(filter(str.isalnum, raw_text)).upper()

        # 2. Length check
        if len(cleaned_text) < MIN_PLATE_LENGTH:
            if DEBUG_MODE and cleaned_text: print(f"  Rejecting: Too short ('{cleaned_text}')")
            return ""

        # 3. Regex pattern check (if defined)
        if EXPECTED_PLATE_PATTERN:
            if not re.fullmatch(EXPECTED_PLATE_PATTERN, cleaned_text):
                if DEBUG_MODE: print(f"  Rejecting: Pattern mismatch ('{cleaned_text}')")
                # Optional: Add character substitution logic here before final rejection
                return ""

        # If all checks pass
        return cleaned_text

    except pytesseract.TesseractNotFoundError:
        print("[ERROR] Tesseract is not installed or not in your PATH.")
        # Consider adding a flag to stop the script if Tesseract isn't found
        return ""
    except Exception as e:
        print(f"[ERROR] OCR failed: {e}")
        return ""


def check_database(plate_text):
    """Checks if the cleaned plate text exists in the database file."""
    if not plate_text: return False
    try:
        with open('Database.txt', 'r') as f:
            # Read lines, strip whitespace, convert to upper, ignore empty lines
            database_plates = {line.strip().upper() for line in f if line.strip()}
        return plate_text in database_plates
    except FileNotFoundError:
        print("[ERROR] Database.txt file not found!")
        # Attempt to create it
        try:
            with open('Database.txt', 'w') as f: pass
            print("[INFO] Created empty Database.txt")
        except IOError:
            print("[ERROR] Could not create Database.txt")
        return False
    except Exception as e:
        print(f"[ERROR] Error reading database: {e}")
        return False


def control_barrier(state):
    """Controls the barrier GPIO pin."""
    if state in [GPIO.HIGH, GPIO.LOW]:
        GPIO.output(BARRIER_PIN, state)
    else:
        print(f"[WARN] Invalid state '{state}' for barrier control.")


def lcd_display(line1, line2=""):
    """Displays text on the LCD, handling potential errors."""
    if not lcd_ready: return
    try:
        lcd.clear()
        lcd.cursor_pos = (0, 0)
        lcd.write_string(str(line1)[:16]) # Truncate to 16 chars
        if line2:
            lcd.cursor_pos = (1, 0)
            lcd.write_string(str(line2)[:16]) # Truncate to 16 chars
    except Exception as e:
        print(f"[ERROR] Failed to write to LCD: {e}")


# ========================
#        MAIN FUNCTION
# ========================
def main():
    print("ðŸš— ANPR System Started...")
    print("Tuning Parameters:")
    print(f"  - Canny: {CANNY_LOW_THRESH}/{CANNY_HIGH_THRESH}, Approx: {CONTOUR_APPROX_FACTOR}")
    print(f"  - Plate Area: >{MIN_PLATE_AREA}, Aspect: {MIN_ASPECT_RATIO}-{MAX_ASPECT_RATIO}")
    print(f"  - Threshold: {THRESHOLD_METHOD} (Block: {ADAPT_THRESH_BLOCK_SIZE}, C: {ADAPT_THRESH_C} if Adaptive)")
    print(f"  - Tesseract: PSM={TESS_PSM}, Whitelist='{TESS_WHITELIST}', MinLen={MIN_PLATE_LENGTH}")
    print(f"  - Timers: Cooldown={PROCESS_COOLDOWN}s, Reset={RESET_TIMEOUT}s")
    print(f"  - Debug Mode: {'ON' if DEBUG_MODE else 'OFF'}")
    print("Press Ctrl+C in this terminal to Quit.")

    lcd_display("ANPR System", "Initializing...")
    time.sleep(1)
    lcd_display("ANPR System", "Ready")

    # State variables
    last_processed_plate = ""  # Stores the plate that triggered the last action
    last_process_time = 0      # Timestamp when the last action (grant/deny) occurred
    last_detection_time = 0    # Timestamp of the last time *any* plate contour was found

    try:
        while True:
            current_time = time.time()
            frame_color = capture_image() # Capture in color first
            if frame_color is None:
                print("[WARN] Failed to capture frame.")
                time.sleep(0.5)
                continue

            plate_found_this_cycle = False # Reset flag each loop
            extracted_plate_img_gray = plate_extraction(frame_color) # Pass color frame

            # --- Process only if a potential plate region was extracted ---
            if extracted_plate_img_gray is not None:
                plate_found_this_cycle = True
                last_detection_time = current_time # Update time whenever a contour is found

                plate_text = ocr_processing(extracted_plate_img_gray) # Pass the extracted GRAY plate

                # --- Process only if OCR returned a valid plate text ---
                if plate_text:
                    # Condition 1: Has cooldown period passed since last action?
                    if current_time - last_process_time > PROCESS_COOLDOWN:
                        # Condition 2: Is this plate different from the one last processed?
                        if plate_text != last_processed_plate:
                            print(f"\nDetected Plate: '{plate_text}'", end=' ')
                            lcd_display("Plate: " + plate_text, "Checking...")

                            # Perform Database Check and Actions
                            if check_database(plate_text):
                                print("[REGISTERED] âœ… Access Granted!")
                                lcd_display(plate_text, "Access Granted")
                                GPIO.output(BUZZ_PIN, GPIO.HIGH)
                                control_barrier(GPIO.HIGH)      # Open
                                time.sleep(0.5)                 # Buzzer duration
                                GPIO.output(BUZZ_PIN, GPIO.LOW)
                                time.sleep(4)                   # Barrier open duration
                                control_barrier(GPIO.LOW)       # Close
                                print(f"-> Processed '{plate_text}'. Starting cooldown.")
                            else: # Access Denied
                                print("[UNREGISTERED] âŒ Access Denied!")
                                lcd_display(plate_text, "Access Denied")
                                for _ in range(3): # Short buzzes
                                    GPIO.output(BUZZ_PIN, GPIO.HIGH); time.sleep(0.1)
                                    GPIO.output(BUZZ_PIN, GPIO.LOW); time.sleep(0.1)
                                time.sleep(1.5) # Show denied message on LCD
                                print(f"-> Processed '{plate_text}'. Starting cooldown.")

                            # === Mark plate as processed and record time ===
                            last_processed_plate = plate_text
                            last_process_time = current_time # Start cooldown timer

                            # Short delay and update LCD after action
                            time.sleep(0.5)
                            lcd_display("ANPR System", "Ready")

                        # Else (condition 2 fail): Same plate as last processed. Ignore.
                        else:
                            if DEBUG_MODE: print(f". (Ignoring repeat '{plate_text}')")
                            pass # Silently ignore during cooldown or if same as last processed

                    # Else (condition 1 fail): Still within cooldown.
                    else:
                         if DEBUG_MODE: print(f". (Cooldown active, ignoring '{plate_text}')")
                         pass # Don't process anything

                # Else (OCR returned empty string): Valid contour, but no text extracted.
                else:
                    if DEBUG_MODE: print(". (Contour found, no valid OCR text)")
                    pass

            # --- End of processing extracted plate ---

            # --- Reset Logic: If NO plate contour found for a while ---
            if not plate_found_this_cycle:
                # Check if enough time has passed since the last time *any* contour was detected
                if current_time - last_detection_time > RESET_TIMEOUT:
                    if last_processed_plate != "": # Only reset if there was a previously processed plate
                        print(f"\nNo plate detected for {RESET_TIMEOUT}s. Resetting process lock.")
                        last_processed_plate = ""
                        lcd_display("ANPR System", "Ready") # Ensure LCD is Ready
                        # Prevent immediate re-resetting by updating detection time
                        last_detection_time = current_time

            # --- Small delay in main loop ---
            time.sleep(0.1) # Adjust as needed for CPU usage / responsiveness trade-off

    except KeyboardInterrupt:
        print("\nðŸ›‘ Ctrl+C detected. Shutting Down...")
    finally:
        print("Cleaning up resources...")
        GPIO.output(BARRIER_PIN, GPIO.LOW) # Ensure barrier closed
        GPIO.output(BUZZ_PIN, GPIO.LOW)    # Ensure buzzer off
        lcd_display("System Stopped", "")
        time.sleep(0.5)
        if lcd_ready:
             try: lcd.clear()
             except Exception: pass
        try:
            picam2.stop()
            print("Camera stopped.")
        except Exception as e:
            print(f"Error stopping camera: {e}")
        GPIO.cleanup()
        print("GPIO Cleaned Up. Exiting.")

# --- Initialization Checks ---
if __name__ == "__main__":
    # Check Tesseract Installation
    try:
        tesseract_version = pytesseract.get_tesseract_version()
        print(f"Tesseract version: {tesseract_version}")
    except pytesseract.TesseractNotFoundError:
        print("="*40)
        print("[FATAL ERROR] Tesseract is not installed or not found in your system's PATH.")
        print("Please install Tesseract OCR:")
        print("  On Debian/Ubuntu/Raspberry Pi OS: sudo apt update && sudo apt install tesseract-ocr")
        print("  Ensure the 'tesseract' command works in your terminal.")
        print("="*40)
        exit(1) # Exit if Tesseract is missing

    # Check Database File
    try:
        with open('Database.txt', 'r') as f:
             db_lines = len(f.readlines())
             print(f"Database.txt found with {db_lines} entries.")
    except FileNotFoundError:
         print("[WARNING] Database.txt not found.")
         try:
             with open('Database.txt', 'w') as f: print("  -> Created empty Database.txt.")
         except IOError as e: print(f"[ERROR] Could not create Database.txt: {e}")

    # --- Start Main Application ---
    main()
//////////////////////////////////
import cv2
import numpy as np
import pytesseract
import RPi.GPIO as GPIO
import time
from picamera2 import Picamera2 # Assuming this is correctly installed and working
from RPLCD.gpio import CharLCD
import re
import os # For saving debug images

# --- Configuration Constants (Tune These!) ---
DEBUG = True  # SET TO True TO SAVE INTERMEDIATE IMAGES FOR DEBUGGING
DEBUG_PATH = "debug_images" # Folder to save debug images

# Plate Extraction
CANNY_LOW_THRESHOLD = 50    # Lowered slightly, was 30
CANNY_HIGH_THRESHOLD = 150  # Lowered slightly, was 180
CONTOUR_CANDIDATES = 20     # Consider more contours, was 10
APPROX_EPSILON = 0.02       # Approximation accuracy, was 0.018
MIN_PLATE_ASPECT_RATIO = 1.2 # Relaxed, was 1.5. UK plates are ~4.4. Short ones are wider.
MAX_PLATE_ASPECT_RATIO = 6.0 # Relaxed, was 5.5
MIN_PLATE_AREA = 300        # Minimum pixel area, was 400. Adjust based on camera resolution & distance

# OCR Processing
OCR_TARGET_HEIGHT = 60
ADAPTIVE_THRESH_BLOCK_SIZE = 19 # Must be odd
ADAPTIVE_THRESH_C = 9
TESSERACT_PSM = 6 # Was 7. Try 6 (uniform block), 8 (single word), 11 (sparse), 13 (raw line)
MIN_PLATE_TEXT_LENGTH = 3  # WAS 4. "9 ASF" has 3 chars. Set to 2 if even shorter plates.
TESSERACT_CHAR_WHITELIST = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

# System Behavior
DEBOUNCE_DISPLAY_TIME = 1
PROCESS_COOLDOWN = 10
RESET_TIMEOUT = 15
BARRIER_OPEN_DURATION = 5 # Increased from 4

# --- GPIO Setup ---
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)

BUZZ_PIN = 18
BARRIER_PIN = 17
GPIO.setup(BUZZ_PIN, GPIO.OUT)
GPIO.setup(BARRIER_PIN, GPIO.OUT)
GPIO.output(BARRIER_PIN, GPIO.LOW)
GPIO.output(BUZZ_PIN, GPIO.LOW)

# --- LCD 1602A Setup ---
try:
    lcd = CharLCD(
        numbering_mode=GPIO.BCM, cols=16, rows=2,
        pin_rs=7, pin_e=8, pins_data=[25, 24, 23, 12],
        charmap='A00', auto_linebreaks=True
    )
    lcd.clear()
    lcd_ready = True
    print("LCD Initialized Successfully.")
except Exception as e:
    print(f"[ERROR] Failed to initialize LCD: {e}")
    lcd_ready = False
    class DummyLCD:
        def write_string(self, text): pass
        def clear(self): pass
        def cursor_pos(self, pos): pass
    lcd = DummyLCD()

import cv2
import numpy as np
import pytesseract
import RPi.GPIO as GPIO # Will work if on Pi, otherwise will fail gracefully on GPIO parts
import time
from picamera2 import Picamera2 # Will work if on Pi & installed
from RPLCD.gpio import CharLCD # Will work if on Pi & installed & wired
import re
import os # For saving debug images

# --- Configuration Constants (Tune These LATER, defaults are for debugging) ---
DEBUG = True
DEBUG_PATH = "debug_images"

# Plate Extraction (Relaxed for Debugging)
CANNY_LOW_THRESHOLD = 50
CANNY_HIGH_THRESHOLD = 150
CONTOUR_CANDIDATES = 25
APPROX_EPSILON = 0.025 # Slightly more permissive
MIN_PLATE_ASPECT_RATIO_DEBUG = 0.8 # Very permissive
MAX_PLATE_ASPECT_RATIO_DEBUG = 8.0 # Very permissive
MIN_PLATE_AREA_DEBUG = 50        # Very permissive, good for small/distant plates

# OCR Processing (Relaxed for Debugging)
OCR_TARGET_HEIGHT = 60
ADAPTIVE_THRESH_BLOCK_SIZE = 19 # Must be odd
ADAPTIVE_THRESH_C = 9
TESSERACT_PSM_DEBUG = 8 # Try 8 (single word), 6 (uniform block), 7 (single line), 11 (sparse text)
MIN_PLATE_TEXT_LENGTH_DEBUG = 1 # Allow even single characters for debug
TESSERACT_CHAR_WHITELIST = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

# System Behavior
DEBOUNCE_DISPLAY_TIME = 1
PROCESS_COOLDOWN = 10
RESET_TIMEOUT = 15
BARRIER_OPEN_DURATION = 5

# --- Path to your Test Image ---
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!  IMPORTANT: CHANGE THIS TO THE ACTUAL PATH TO YOUR IMAGE   !!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
TEST_IMAGE_PATH = "path/to/your/lamborghini.jpg" # E.g., "/home/pi/images/lamborghini.jpg" or "lamborghini.jpg" if in same folder


# --- GPIO Setup ---
try:
    GPIO.setwarnings(False)
    GPIO.setmode(GPIO.BCM)
    BUZZ_PIN = 18
    BARRIER_PIN = 17
    GPIO.setup(BUZZ_PIN, GPIO.OUT)
    GPIO.setup(BARRIER_PIN, GPIO.OUT)
    GPIO.output(BARRIER_PIN, GPIO.LOW)
    GPIO.output(BUZZ_PIN, GPIO.LOW)
    gpio_ok = True
    print("GPIO Initialized (or skipped if not on Pi).")
except Exception as e:
    print(f"[WARN] GPIO setup failed (this is okay if not on a Pi): {e}")
    gpio_ok = False
    # Define dummy GPIO if needed for functions, though current code doesn't strictly need it if gpio_ok is false
    class DummyGPIO:
        HIGH = 1
        LOW = 0
        OUT = 1
        BCM = 1
        def setup(self, pin, mode): pass
        def output(self, pin, state): pass
        def cleanup(self): pass
        def setwarnings(self, val): pass
        def setmode(self, val): pass
    GPIO = DummyGPIO()


# --- LCD 1602A Setup ---
try:
    if not gpio_ok: raise RuntimeError("GPIO not available for LCD")
    lcd = CharLCD(
        numbering_mode=GPIO.BCM, cols=16, rows=2,
        pin_rs=7, pin_e=8, pins_data=[25, 24, 23, 12],
        charmap='A00', auto_linebreaks=True
    )
    lcd.clear()
    lcd_ready = True
    print("LCD Initialized Successfully.")
except Exception as e:
    print(f"[WARN] Failed to initialize LCD (this is okay if not on Pi/wired): {e}")
    lcd_ready = False
    class DummyLCD:
        def write_string(self, text): pass
        def clear(self): pass
        def cursor_pos(self, pos): pass
    lcd = DummyLCD()

# --- PiCamera2 Setup ---
picam2 = None
camera_ready = False
if TEST_IMAGE_PATH is None: # Only setup camera if not using a test image
    try:
        picam2 = Picamera2()
        picam2.configure(picam2.create_preview_configuration(main={"size": (1024, 576)}))
        picam2.start()
        time.sleep(2.0)
        print("Camera Initialized.")
        camera_ready = True
    except Exception as e:
        print(f"[WARN] Failed to initialize PiCamera2 (this is okay if not on Pi or cam not connected): {e}")
        camera_ready = False
else:
    print(f"INFO: Camera inactive. Using test image: {TEST_IMAGE_PATH}")
    if not os.path.exists(TEST_IMAGE_PATH):
        print(f"[FATAL ERROR] Test image not found: {TEST_IMAGE_PATH}")
        print("Please update the TEST_IMAGE_PATH variable with the correct file path.")
        exit()


# --- Debugging Helper ---
if DEBUG:
    if not os.path.exists(DEBUG_PATH):
        try:
            os.makedirs(DEBUG_PATH)
            print(f"Created debug directory: {DEBUG_PATH}")
        except OSError as e:
            print(f"[ERROR] Could not create debug directory {DEBUG_PATH}: {e}. Debug images will not be saved.")
            DEBUG = False # Disable debug image saving if dir creation fails

def save_debug_image(name, image_data):
    if DEBUG and image_data is not None and image_data.size > 0:
        try:
            cv2.imwrite(os.path.join(DEBUG_PATH, name), image_data)
            print(f"[DEBUG] Saved image: {name}")
        except Exception as e:
            print(f"[DEBUG-ERROR] Could not save {name}: {e}")

# --- Helper Function for Perspective Transform --- (Usually okay)
def order_points(pts):
    rect = np.zeros((4, 2), dtype="float32")
    s = pts.sum(axis=1)
    rect[0] = pts[np.argmin(s)]
    rect[2] = pts[np.argmax(s)]
    diff = np.diff(pts, axis=1)
    rect[1] = pts[np.argmin(diff)]
    rect[3] = pts[np.argmax(diff)]
    return rect

def perspective_transform(image, pts):
    rect = order_points(pts)
    (tl, tr, br, bl) = rect
    widthA = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))
    widthB = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))
    maxWidth = max(int(widthA), int(widthB))
    heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))
    heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))
    maxHeight = max(int(heightA), int(heightB))
    if maxWidth <= 0 or maxHeight <= 0:
        print("[WARN] Invalid dimensions for perspective transform.")
        return None
    dst = np.array([[0, 0], [maxWidth - 1, 0], [maxWidth - 1, maxHeight - 1], [0, maxHeight - 1]], dtype="float32")
    M = cv2.getPerspectiveTransform(rect, dst)
    warped = cv2.warpPerspective(image, M, (maxWidth, maxHeight))
    return warped

# --- Image Processing Functions ---
def capture_image():
    if TEST_IMAGE_PATH:
        print(f"[DEBUG] Reading test image from: {TEST_IMAGE_PATH}")
        frame = cv2.imread(TEST_IMAGE_PATH)
        if frame is None:
            print(f"[ERROR] Could not read test image: {TEST_IMAGE_PATH}. Check path and file.")
            return None
        return frame
    elif camera_ready and picam2:
        frame = picam2.capture_array("main")
        frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
        return frame
    print("[WARN] No image source available (Camera not ready and no TEST_IMAGE_PATH).")
    return None

def plate_extraction(image):
    if image is None or image.size == 0:
        print("[PLATE EXTRACT] Input image is empty.")
        return None
    save_debug_image("0_plate_extraction_input.png", image)
    print("[PLATE EXTRACT] Starting plate_extraction...")

    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    save_debug_image("1_gray.png", gray)

    # Bilateral filter is good for noise reduction while keeping edges sharp
    # Parameters: (image, diameter of pixel neighborhood, sigmaColor, sigmaSpace)
    # Higher sigmaColor means more colors in the neighborhood will be mixed together.
    # Higher sigmaSpace means pixels farther out will influence each other.
    blur = cv2.bilateralFilter(gray, d=9, sigmaColor=75, sigmaSpace=75)
    # Alternative: GaussianBlur
    # blur = cv2.GaussianBlur(gray, (5,5), 0)
    save_debug_image("2_blur.png", blur)
    print(f"[PLATE EXTRACT] Applied blur. CANNY thresholds: Low={CANNY_LOW_THRESHOLD}, High={CANNY_HIGH_THRESHOLD}")

    edges = cv2.Canny(blur, CANNY_LOW_THRESHOLD, CANNY_HIGH_THRESHOLD)
    save_debug_image("3_edges.png", edges)

    cnts, _ = cv2.findContours(edges.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    print(f"[PLATE EXTRACT] Found {len(cnts)} initial contours. Considering top {CONTOUR_CANDIDATES}.")

    if not cnts:
        print("[PLATE EXTRACT] No contours found after Canny edge detection.")
        return None

    # For debugging, draw all significant contours
    img_with_all_contours = image.copy()
    cv2.drawContours(img_with_all_contours, sorted(cnts, key=cv2.contourArea, reverse=True)[:50], -1, (0,255,0), 1) # Draw top 50 contours
    save_debug_image("4_all_contours_drawn.png", img_with_all_contours)

    cnts = sorted(cnts, key=cv2.contourArea, reverse=True)[:CONTOUR_CANDIDATES]

    plate_contour_final = None # Renamed to avoid conflict
    img_with_candidate_contours = image.copy()

    print(f"[PLATE EXTRACT] Filtering top {len(cnts)} contours. Epsilon={APPROX_EPSILON*100}%, MinArea={MIN_PLATE_AREA_DEBUG}, AspectRange=({MIN_PLATE_ASPECT_RATIO_DEBUG}-{MAX_PLATE_ASPECT_RATIO_DEBUG})")
    found_candidates = 0
    for i, c in enumerate(cnts):
        perimeter = cv2.arcLength(c, True)
        approx = cv2.approxPolyDP(c, APPROX_EPSILON * perimeter, True)
        num_points = len(approx)

        (x, y, w, h) = cv2.boundingRect(approx) # Get bounding box for aspect ratio
        aspect_ratio = w / float(h) if h > 0 else 0
        area = cv2.contourArea(approx)

        # Draw candidate in blue
        cv2.drawContours(img_with_candidate_contours, [approx], -1, (255,0,0), 1)

        # Relaxed check for DEBUGGING
        if (3 <= num_points <= 7 and # Allow more variation in points for debug
            aspect_ratio >= MIN_PLATE_ASPECT_RATIO_DEBUG and
            aspect_ratio <= MAX_PLATE_ASPECT_RATIO_DEBUG and
            area > MIN_PLATE_AREA_DEBUG):

            print(f"[PLATE EXTRACT Candidate {i+1}] PASSED: Points={num_points}, Area={area:.0f}, AspectRatio={aspect_ratio:.2f}")
            cv2.drawContours(img_with_candidate_contours, [approx], -1, (0,0,255), 3) # Draw chosen in red thick
            plate_contour_final = approx
            found_candidates+=1
            break # Found a plausible plate
        else:
            reason = []
            if not (3 <= num_points <= 7) : reason.append(f"Points:{num_points}")
            if not (aspect_ratio >= MIN_PLATE_ASPECT_RATIO_DEBUG and aspect_ratio <= MAX_PLATE_ASPECT_RATIO_DEBUG): reason.append(f"Aspect:{aspect_ratio:.2f}")
            if not (area > MIN_PLATE_AREA_DEBUG): reason.append(f"Area:{area:.0f}")
            print(f"[PLATE EXTRACT Candidate {i+1}] FAILED: Points={num_points}, Area={area:.0f}, AspectRatio={aspect_ratio:.2f}. Reasons: {', '.join(reason)}")


    save_debug_image("5_candidate_contours_drawn.png", img_with_candidate_contours)

    if plate_contour_final is None:
        print("[PLATE EXTRACT] No suitable plate contour found after filtering.")
        return None
    else:
        print(f"[PLATE EXTRACT] Selected a plate contour with {len(plate_contour_final)} points.")
        # If the selected contour doesn't have 4 points, perspective transform will fail.
        # For a robust solution, one might try to find the best 4 points from these if more exist,
        # or use cv2.minAreaRect for a rotated rectangle. For now, this is a known limitation if not 4 points.
        if len(plate_contour_final) != 4:
            print(f"[WARN] Selected contour has {len(plate_contour_final)} points, not 4. Perspective transform might be inaccurate or fail.")
            # Attempt to get a bounding rect and use its corners as a crude approximation for non-4-point contours
            rect = cv2.minAreaRect(plate_contour_final)
            box = cv2.boxPoints(rect)
            approx_4_points = np.int0(box)
            if len(approx_4_points) == 4:
                 print("[WARN] Using minAreaRect to approximate 4 points for warp.")
                 pts = approx_4_points.reshape(4,2)
                 # It might be better to use the original color image portion for warping
                 x_br, y_br, w_br, h_br = cv2.boundingRect(plate_contour_final)
                 cropped_for_warp = image[y_br:y_br+h_br, x_br:x_br+w_br]
                 # The pts from boxPoints might be relative to the whole image or cropped_for_warp's origin might be an issue.
                 # This part needs careful handling if we go this route. For now, simpler:
                 # if the number of points is not 4 perspective_transform will likely give issues.
                 # So we just try with the points we have and let it fail if it does.
                 # This is a key area for improvement if non-rectangular plates are common.

            else: # Still no 4 points, just try with the original
                 pts = plate_contour_final.reshape(len(plate_contour_final),2) # This will likely fail in order_points or getPerspectiveTransform
                 print(f"[WARN] Reshaping to {pts.shape}, order_points may fail.")
                 # Fallback: return None if we can't reliably get 4 points for warping
                 # print("[PLATE EXTRACT] Could not ensure 4 points for warp. Aborting extraction for this contour.")
                 # return None

            # For now, we'll just pass the points we found.
            # The user needs to see if `order_points` and `perspective_transform` handle non-4-point input or how it fails.
            # A simpler fallback for debug:
            if len(plate_contour_final) !=4:
                 print("[WARN] Cannot perform perspective warp reliably without 4 points. Trying to crop by bounding box instead (less accurate).")
                 x, y, w, h = cv2.boundingRect(plate_contour_final)
                 cropped_plate = image[y:y+h, x:x+w]
                 save_debug_image("7_crude_crop_no_warp.png", cropped_plate)
                 return cropped_plate # Not ideal, but better than nothing for OCR debug if warp fails.
        
        # Ideal path: contour has 4 points
        pts = plate_contour_final.reshape(4, 2)
        warped_plate = perspective_transform(image, pts) # Use original color image for warp

        if warped_plate is None or warped_plate.size == 0:
            print("[PLATE EXTRACT] Warped plate is empty or perspective transform failed.")
            return None
        
        save_debug_image("7_warped_plate.png", warped_plate)
        print("[PLATE EXTRACT] Plate extracted and warped successfully.")
        return warped_plate

def ocr_processing(plate_image):
    if plate_image is None or plate_image.size == 0:
        print("[OCR] Input plate image is empty.")
        return ""
    print("[OCR] Starting OCR processing...")
    save_debug_image("8_ocr_input_plate.png", plate_image)

    target_height = OCR_TARGET_HEIGHT
    h, w = plate_image.shape[:2]
    if h == 0 or w == 0:
        print("[OCR] Invalid plate image dimensions (height or width is 0).")
        return ""
    aspect_ratio = w / float(h)
    target_width = int(target_height * aspect_ratio)

    plate_image_resized = plate_image
    if target_width > 0 and target_height > 0:
        try:
            plate_image_resized = cv2.resize(plate_image, (target_width, target_height), interpolation=cv2.INTER_LANCZOS4)
            save_debug_image("9_ocr_resized.png", plate_image_resized)
            print(f"[OCR] Resized plate to {target_width}x{target_height}.")
        except cv2.error as e:
            print(f"[OCR-WARN] Resize failed: {e}. Using original size for OCR.")
            pass
    else:
        print(f"[OCR-WARN] Invalid target dims for OCR resize: W={target_width}, H={target_height}. Using original size.")

    gray_plate = cv2.cvtColor(plate_image_resized, cv2.COLOR_BGR2GRAY)
    save_debug_image("10_ocr_gray.png", gray_plate)

    print(f"[OCR] Applying adaptive threshold: BlockSize={ADAPTIVE_THRESH_BLOCK_SIZE}, C={ADAPTIVE_THRESH_C}")
    binary_plate = cv2.adaptiveThreshold(
        gray_plate, 255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY_INV,
        ADAPTIVE_THRESH_BLOCK_SIZE,
        ADAPTIVE_THRESH_C
    )
    # Optional: Add some morphology (e.g., opening) to remove small noise
    # kernel_size = (2,2) # Very small kernel
    # kernel = np.ones(kernel_size,np.uint8)
    # binary_plate = cv2.morphologyEx(binary_plate, cv2.MORPH_OPEN, kernel)
    # print(f"[OCR] Applied morphology OPEN with kernel {kernel_size}")

    save_debug_image("11_ocr_binary_plate.png", binary_plate)

    custom_config = f'--oem 3 --psm {TESSERACT_PSM_DEBUG}'
    if TESSERACT_CHAR_WHITELIST:
        custom_config += f' -c tessedit_char_whitelist={TESSERACT_CHAR_WHITELIST}'
    print(f"[OCR] Tesseract config: '{custom_config}'")

    try:
        text = pytesseract.image_to_string(binary_plate, config=custom_config)
        print(f"[OCR] Raw Tesseract Output: '{text.strip()}'")

        cleaned_text = text.strip()
        cleaned_text = ''.join(filter(str.isalnum, cleaned_text)).upper()
        print(f"[OCR] Cleaned (isalnum, upper): '{cleaned_text}'")

        if len(cleaned_text) < MIN_PLATE_TEXT_LENGTH_DEBUG:
            print(f"[OCR] Cleaned text '{cleaned_text}' (len {len(cleaned_text)}) is shorter than min length {MIN_PLATE_TEXT_LENGTH_DEBUG}. Discarding.")
            return ""
        print(f"[OCR] Final plate text: '{cleaned_text}'")
        return cleaned_text
    except pytesseract.TesseractNotFoundError:
        print("[ERROR] Tesseract is not installed or not in your PATH. Please install Tesseract OCR.")
        return "TESS_ERROR"
    except Exception as e:
        print(f"[ERROR] OCR processing failed with Tesseract: {e}")
        return ""

def check_database(plate_text):
    if not plate_text or plate_text == "TESS_ERROR":
        print(f"[DB CHECK] Invalid plate text for DB check: '{plate_text}'")
        return False
    print(f"[DB CHECK] Checking database for: '{plate_text}'")
    try:
        with open('Database.txt', 'r') as f:
            database_plates = {line.strip().upper() for line in f if line.strip()}
        if plate_text in database_plates:
            print(f"[DB CHECK] Plate '{plate_text}' FOUND in database.")
            return True
        else:
            print(f"[DB CHECK] Plate '{plate_text}' NOT FOUND in database.")
            return False
    except FileNotFoundError:
        print("[ERROR] Database.txt file not found! Cannot check plate.")
        try:
            with open('Database.txt', 'w') as f: pass # Create empty
            print("[WARN] Created empty Database.txt. Plate will not be found.")
        except IOError: print("[ERROR] Could not create Database.txt.")
        return False
    except Exception as e:
        print(f"[ERROR] Error reading database: {e}")
        return False

def control_barrier(state):
    if gpio_ok:
        GPIO.output(BARRIER_PIN, state)
        print(f"[CONTROL] Barrier set to {'HIGH (Open)' if state else 'LOW (Closed)'}")
    else:
        print("[CONTROL-WARN] GPIO not available, cannot control barrier.")

def lcd_display(line1, line2=""):
    if lcd_ready:
        try:
            lcd.clear()
            lcd.cursor_pos = (0, 0)
            lcd.write_string(str(line1)[:16])
            if line2:
                lcd.cursor_pos = (1, 0)
                lcd.write_string(str(line2)[:16])
            # print(f"[LCD] Displayed: L1='{str(line1)[:16]}', L2='{str(line2)[:16]}'") # For console log of LCD
        except Exception as e:
            print(f"[ERROR] Failed to write to LCD: {e}")
    # else:
    #     print(f"[LCD-WARN] LCD not ready. Tried to display: L1='{str(line1)[:16]}', L2='{str(line2)[:16]}'")


# ========================
#        MAIN FUNCTION
# ========================
def main():
    print("ðŸš— ANPR System Started (Debug Mode)...")
    lcd_display("ANPR Debug", "Initializing...")
    time.sleep(0.2) # Shorten for debug

    last_detected_plate = ""
    last_processed_plate = ""
    last_detection_time = 0
    last_process_time = 0

    is_first_loop = True

    try:
        while True:
            current_time = time.time()
            print("\n--- Main Loop Cycle Start ---")
            frame = capture_image()

            if frame is None:
                if TEST_IMAGE_PATH:
                    print("FATAL: Test image specified but could not be loaded. Exiting.")
                    break
                print("[WARN] Main loop: Failed to capture frame.")
                if is_first_loop: lcd_display("ANPR Debug", "Cam Error")
                time.sleep(0.5)
                is_first_loop = False
                continue
            
            if is_first_loop:
                lcd_display("ANPR Debug", "Processing...")
                is_first_loop = False

            plate_found_this_cycle = False
            extracted_plate_img = plate_extraction(frame)

            if extracted_plate_img is not None:
                plate_found_this_cycle = True # A region was extracted
                print("[MAIN] Plate region extracted. Proceeding to OCR.")
                plate_text = ocr_processing(extracted_plate_img)

                if plate_text and plate_text != "TESS_ERROR":
                    print(f"[MAIN] OCR successful: '{plate_text}'")
                    last_detection_time = current_time

                    if current_time - last_process_time > PROCESS_COOLDOWN:
                        if plate_text != last_processed_plate:
                            print(f"[MAIN] New plate '{plate_text}' for processing (last was '{last_processed_plate}').")
                            lcd_display("Plate: " + plate_text, "Checking DB...")
                            last_detected_plate = plate_text

                            if check_database(plate_text):
                                print(f"[MAIN] Plate '{plate_text}' REGISTERED. Access Granted!")
                                lcd_display(plate_text, "Access Granted")
                                if gpio_ok: GPIO.output(BUZZ_PIN, GPIO.HIGH)
                                control_barrier(GPIO.HIGH)
                                time.sleep(0.5)
                                if gpio_ok: GPIO.output(BUZZ_PIN, GPIO.LOW)
                                time.sleep(BARRIER_OPEN_DURATION)
                                control_barrier(GPIO.LOW)
                                print(f"[MAIN] Processed '{plate_text}'. Starting cooldown.")
                            else:
                                print(f"[MAIN] Plate '{plate_text}' UNREGISTERED. Access Denied!")
                                lcd_display(plate_text, "Access Denied")
                                if gpio_ok:
                                    for _ in range(3):
                                        GPIO.output(BUZZ_PIN, GPIO.HIGH); time.sleep(0.1)
                                        GPIO.output(BUZZ_PIN, GPIO.LOW); time.sleep(0.1)
                                time.sleep(1.5)
                                print(f"[MAIN] Processed '{plate_text}' (denied). Starting cooldown.")

                            last_processed_plate = plate_text
                            last_process_time = current_time
                            lcd_display("ANPR Debug", "Ready...")
                        else:
                            print(f"[MAIN] Plate '{plate_text}' is same as last processed ('{last_processed_plate}'). Ignoring during cooldown.")
                    else:
                        print(f"[MAIN] Still in cooldown from processing '{last_processed_plate}'. Time remaining: {PROCESS_COOLDOWN - (current_time - last_process_time):.1f}s")
                elif plate_text == "TESS_ERROR":
                     print("[MAIN] OCR process reported Tesseract error.")
                     lcd_display("OCR Error", "Tesseract fail")
                     # Potentially start a cooldown for this specific error to avoid spam
                else: # OCR returned empty string
                    print("[MAIN] OCR did not find valid text on the extracted plate region.")
                    # Optionally update lcd_display to show "No text found" or similar
            else: # No plate region extracted
                print("[MAIN] No plate region extracted by plate_extraction function.")


            if not plate_found_this_cycle:
                if current_time - last_detection_time > RESET_TIMEOUT:
                    if last_processed_plate != "":
                        print(f"\n[MAIN] No valid plate OCR for {RESET_TIMEOUT}s. Resetting lock for '{last_processed_plate}'.")
                        lcd_display("ANPR Debug", "Resetting...")
                        last_processed_plate = ""
                        last_detected_plate = ""
            
            if TEST_IMAGE_PATH:
                print("\n--- Processed test image. Exiting main loop. ---")
                break # Exit after processing one test image

            time.sleep(0.1) # Main loop delay if not using test image

    except KeyboardInterrupt:
        print("\nðŸ›‘ Ctrl+C detected. Shutting Down...")
    except Exception as e:
        print(f"\nðŸ’¥ UNEXPECTED ERROR in main loop: {e}")
        import traceback
        traceback.print_exc() # Print full stack trace
    finally:
        print("--- Cleaning up resources... ---")
        if gpio_ok:
            GPIO.output(BARRIER_PIN, GPIO.LOW)
            GPIO.output(BUZZ_PIN, GPIO.LOW)
        lcd_display("System OFF", "")
        time.sleep(0.5)
        if lcd_ready and isinstance(lcd, CharLCD):
            try: lcd.clear()
            except: pass
        if camera_ready and picam2:
            try: picam2.stop()
            except: pass
            print("Camera stopped.")
        if gpio_ok:
            GPIO.cleanup()
            print("GPIO Cleaned Up.")
        print("Exiting.")

# --- Initialization Checks ---
if __name__ == "__main__":
    print("--- System Pre-checks ---")
    try:
        tesseract_version = pytesseract.get_tesseract_version()
        print(f"Tesseract version: {tesseract_version}")
    except pytesseract.TesseractNotFoundError:
        print("[FATAL ERROR] Tesseract is not installed or not found in your system's PATH.")
        print("Please install Tesseract OCR: https://github.com/tesseract-ocr/tesseract")
        print("And make sure the `pytesseract` Python library is installed (`pip install pytesseract`)")
        exit(1)
    except Exception as e:
        print(f"[ERROR] Could not get Tesseract version: {e}. OCR might fail.")

    try:
        with open('Database.txt', 'r') as f:
            print("Database.txt found.")
    except FileNotFoundError:
        print("[WARNING] Database.txt not found. Creating empty file.")
        try:
            with open('Database.txt', 'w') as f: pass
        except IOError as e: print(f"[ERROR] Could not create Database.txt: {e}")
    
    print("--- Starting Main Application ---")
    main()
