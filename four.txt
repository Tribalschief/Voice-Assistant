import cv2
import numpy as np
import pytesseract
import RPi.GPIO as GPIO
import time
from picamera2 import Picamera2
from RPLCD.gpio import CharLCD
import re # Import regex module for more flexible cleaning

# --- GPIO Setup ---
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)

BUZZ_PIN = 18
BARRIER_PIN = 17
GPIO.setup(BUZZ_PIN, GPIO.OUT)
GPIO.setup(BARRIER_PIN, GPIO.OUT)
GPIO.output(BARRIER_PIN, GPIO.LOW) # Ensure barrier is closed at start
GPIO.output(BUZZ_PIN, GPIO.LOW)   # Ensure buzzer is off at start

# --- LCD 1602A Setup (Without I2C) ---
# !! DOUBLE CHECK THESE PINS MATCH YOUR WIRING !!
try:
    lcd = CharLCD(
        numbering_mode=GPIO.BCM,
        cols=16,
        rows=2,
        pin_rs=7,
        pin_e=8,
        pins_data=[25, 24, 23, 12],
        charmap='A00', # Standard European character map (only affects LCD display, not OCR)
        auto_linebreaks=True
    )
    lcd.clear() # Clear display on startup
    lcd_ready = True
    print("LCD Initialized Successfully.")
except Exception as e:
    print(f"[ERROR] Failed to initialize LCD: {e}")
    print("Check GPIO connections and RPLCD installation.")
    lcd_ready = False
    # Define dummy lcd functions if init fails to avoid errors later
    class DummyLCD:
        def write_string(self, text): pass
        def clear(self): pass
        def cursor_pos(self, pos): pass
    lcd = DummyLCD()


# --- PiCamera2 Setup ---
picam2 = Picamera2()
# Consider image size trade-offs:
# Smaller (e.g., 640, 480): Faster processing, lower resolution for distant plates.
# Larger (e.g., 1280, 720): Slower processing, better detail. (1024, 576) is a good compromise.
picam2.configure(picam2.create_preview_configuration(main={"size": (1024, 576)}))
picam2.start()
# Allow camera sensor to settle
time.sleep(2.0)
print("Camera Initialized.")


# --- Helper Function for Perspective Transform ---
# (Keep this function as is, it's standard geometry)
def order_points(pts):
    rect = np.zeros((4, 2), dtype="float32")
    s = pts.sum(axis=1)
    rect[0] = pts[np.argmin(s)]
    rect[2] = pts[np.argmax(s)]
    diff = np.diff(pts, axis=1)
    rect[1] = pts[np.argmin(diff)]
    rect[3] = pts[np.argmax(diff)]
    return rect

def perspective_transform(image, pts):
    rect = order_points(pts)
    (tl, tr, br, bl) = rect
    widthA = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))
    widthB = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))
    maxWidth = max(int(widthA), int(widthB))
    heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))
    heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))
    maxHeight = max(int(heightA), int(heightB))

    # Make sure dimensions are valid before creating dst array
    if maxWidth <= 0 or maxHeight <= 0:
        print("[WARN] Invalid dimensions calculated for perspective transform.")
        return None # Return None if dimensions are invalid

    dst = np.array([
        [0, 0],
        [maxWidth - 1, 0],
        [maxWidth - 1, maxHeight - 1],
        [0, maxHeight - 1]], dtype="float32")

    M = cv2.getPerspectiveTransform(rect, dst)
    warped = cv2.warpPerspective(image, M, (maxWidth, maxHeight))
    return warped

# --- Image Processing Functions ---
def capture_image():
    # Capture frame as numpy array BGR format
    frame = picam2.capture_array("main")
    # Picamera2 usually gives RGB, OpenCV expects BGR.
    # Double-check this: If colors look swapped (blue/red), uncomment the line below.
    frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR) # UNCOMMENTED based on common picam2 usage
    return frame

def plate_extraction(image):
    if image is None or image.size == 0: return None # Add check for valid input image

    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blur = cv2.bilateralFilter(gray, 11, 17, 17)
    edges = cv2.Canny(blur, 30, 180) # Wider range might catch plates in varying light
                                     # TUNE THIS: Low threshold (30) / High threshold (180)

    cnts, _ = cv2.findContours(edges.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    cnts = sorted(cnts, key=cv2.contourArea, reverse=True)[:10] # Check top 10

    plate_contour = None
    for c in cnts:
        perimeter = cv2.arcLength(c, True)
        epsilon = 0.018 # TUNE THIS: Approximation accuracy
        approx = cv2.approxPolyDP(c, epsilon * perimeter, True)

        if len(approx) == 4:
            # Basic Aspect Ratio and Area Check (optional but recommended)
            (x, y, w, h) = cv2.boundingRect(approx)
            aspect_ratio = w / float(h) if h > 0 else 0
            area = cv2.contourArea(approx)

            # Adjust these min/max values based on expected plate size/distance in your setup
            min_aspect_ratio = 1.5
            max_aspect_ratio = 5.5
            min_area = 400 # Minimum pixel area to reduce noise

            if aspect_ratio >= min_aspect_ratio and aspect_ratio <= max_aspect_ratio and area > min_area:
                plate_contour = approx
                break # Found a plausible plate

    if plate_contour is None:
        return None
    else:
        pts = plate_contour.reshape(4, 2)
        warped_plate = perspective_transform(image, pts) # Use color image

        if warped_plate is None or warped_plate.size == 0:
             return None

        return warped_plate

def ocr_processing(plate_image):
    if plate_image is None or plate_image.size == 0:
        return ""

    target_height = 60
    aspect_ratio = plate_image.shape[1] / plate_image.shape[0]
    target_width = int(target_height * aspect_ratio)
    if target_width > 0 and target_height > 0:
         try:
            plate_image_resized = cv2.resize(plate_image, (target_width, target_height), interpolation=cv2.INTER_LANCZOS4)
         except cv2.error:
             plate_image_resized = plate_image # Use original if resize fails
    else:
        plate_image_resized = plate_image # Use original if dims invalid

    gray_plate = cv2.cvtColor(plate_image_resized, cv2.COLOR_BGR2GRAY)
    # No blur initially often works ok with adaptive threshold
    # blurred_plate = cv2.GaussianBlur(gray_plate, (3, 3), 0)

    binary_plate = cv2.adaptiveThreshold(
        gray_plate, # Use gray directly
        255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY_INV,
        19, # TUNE THIS: Block Size (try larger if chars are thick)
        9   # TUNE THIS: Constant C (increase if too much noise included, decrease if chars broken)
    )

    # --- Tesseract OCR ---
    # TUNE THIS: PSM mode (7: single line, 8: single word, 6: uniform block, 11: sparse)
    custom_config = r'--oem 3 --psm 7'

    try:
        text = pytesseract.image_to_string(binary_plate, config=custom_config)

        # --- OCR Cleanup ---
        cleaned_text = text.strip()
        # Basic alphanumeric cleanup + uppercase
        cleaned_text = ''.join(filter(str.isalnum, cleaned_text)).upper()
        # Example more advanced cleanup (remove leading/trailing non-letters/numbers)
        # cleaned_text = re.sub(r'^[^A-Z0-9]+|[^A-Z0-9]+$', '', cleaned_text)

        # TUNE THIS: Minimum plate length
        if len(cleaned_text) < 4:
            return ""

        return cleaned_text
    except pytesseract.TesseractNotFoundError:
        print("[ERROR] Tesseract is not installed or not in your PATH.")
        return ""
    except Exception as e:
        print(f"[ERROR] OCR failed: {e}")
        return ""


def check_database(plate_text):
    if not plate_text:
        return False
    try:
        with open('Database.txt', 'r') as f:
            database_plates = {line.strip().upper() for line in f if line.strip()}
            return plate_text in database_plates
    except FileNotFoundError:
        print("[ERROR] Database.txt file not found!")
        try:
             with open('Database.txt', 'w') as f: pass # Create empty
             print("[WARN] Created empty Database.txt")
        except IOError: print("[ERROR] Could not create Database.txt")
        return False
    except Exception as e:
        print(f"[ERROR] Error reading database: {e}")
        return False


def control_barrier(state):
    if state in [GPIO.HIGH, GPIO.LOW]:
        GPIO.output(BARRIER_PIN, state)
    else:
        print(f"[WARN] Invalid state '{state}' for barrier control.")


def lcd_display(line1, line2=""):
    if not lcd_ready: return
    try:
        lcd.clear()
        lcd.cursor_pos = (0, 0)
        lcd.write_string(str(line1)[:16])
        if line2:
            lcd.cursor_pos = (1, 0)
            lcd.write_string(str(line2)[:16])
    except Exception as e:
        print(f"[ERROR] Failed to write to LCD: {e}")


# ========================
#        MAIN FUNCTION
# ========================
def main():
    print("ðŸš— ANPR System Started...")
    print("Press Ctrl+C in this terminal to Quit.")
    lcd_display("ANPR System", "Initializing...")
    time.sleep(1)
    lcd_display("ANPR System", "Ready")

    last_detected_plate = ""     # Stores the most recent OCR result string
    last_processed_plate = ""  # << NEW: Stores the plate that triggered the last action
    last_detection_time = 0    # Timestamp of the last time *any* plate was detected by OCR
    last_process_time = 0      # << NEW: Timestamp when the last action (grant/deny) occurred
    # TUNE THESE: Delays and Timeouts
    debounce_display_time = 1  # Seconds before showing the same detected plate again in console/LCD
    process_cooldown = 10      # << NEW: Seconds to wait *after* an action before processing ANY plate again
    reset_timeout = 15         # << NEW: Seconds without ANY plate detection before resetting 'last_processed_plate'

    try:
        while True:
            current_time = time.time()
            frame = capture_image()
            if frame is None:
                print("[WARN] Failed to capture frame.")
                time.sleep(0.5)
                continue

            plate_found = False # Flag to track if *any* plate contour was found this frame
            extracted_plate_img = plate_extraction(frame)

            # --- Process only if a plate region was extracted ---
            if extracted_plate_img is not None:
                plate_found = True
                plate_text = ocr_processing(extracted_plate_img)

                # --- Process only if OCR returned a valid-looking plate ---
                if plate_text:
                    last_detection_time = current_time # Update time whenever OCR finds something

                    # --- Condition 1: Has enough time passed since the *last action*? ---
                    if current_time - last_process_time > process_cooldown:

                        # --- Condition 2: Is this plate different from the one last *processed*? ---
                        if plate_text != last_processed_plate:

                            # --- Condition 3 (Display Debounce): Is it different from last *detection* OR enough time passed? ---
                            # This prevents console/LCD spam if OCR flickers briefly before stabilizing on the NEW plate.
                            if plate_text != last_detected_plate or (current_time - last_detection_time > debounce_display_time):
                                print(f"Detected Plate: '{plate_text}'", end=' ')
                                lcd_display("Plate: " + plate_text, "Checking...")
                                # Update last_detected_plate *only* when we display/log it
                                last_detected_plate = plate_text
                                # NOTE: last_detection_time was already updated above

                                # --- Perform the actual Database Check and Actions ---
                                if check_database(plate_text):
                                    print("[REGISTERED] âœ… Access Granted!")
                                    lcd_display(plate_text, "Access Granted")
                                    GPIO.output(BUZZ_PIN, GPIO.HIGH)
                                    control_barrier(GPIO.HIGH)      # Open
                                    time.sleep(0.5)                 # Buzzer on duration
                                    GPIO.output(BUZZ_PIN, GPIO.LOW)
                                    time.sleep(4)                   # Barrier open duration << INCREASED?
                                    control_barrier(GPIO.LOW)       # Close
                                    print(f"-> Processed '{plate_text}'. Starting cooldown.")

                                else: # Access Denied
                                    print("[UNREGISTERED] âŒ Access Denied!")
                                    lcd_display(plate_text, "Access Denied")
                                    # Short buzzes for denial
                                    for _ in range(3):
                                        GPIO.output(BUZZ_PIN, GPIO.HIGH)
                                        time.sleep(0.1)
                                        GPIO.output(BUZZ_PIN, GPIO.LOW)
                                        time.sleep(0.1)
                                    time.sleep(1.5) # Show denied message
                                    print(f"-> Processed '{plate_text}'. Starting cooldown.")

                                # === IMPORTANT: Mark plate as processed and record time ===
                                last_processed_plate = plate_text
                                last_process_time = current_time # Start cooldown timer
                                last_detected_plate = "" # Reset last detected to force redisplay if seen again after cooldown

                                # --- Update LCD to Ready after action ---
                                lcd_display("ANPR System", "Ready")
                                time.sleep(0.5) # Small pause before scanning again

                            # Else (condition 3 fail): Plate is new compared to last *processed*,
                            # but same as last *detected* within display debounce time. Do nothing this cycle.
                            # Let OCR stabilize or wait for display debounce timeout.

                        # Else (condition 2 fail): Same plate as last processed. Ignore during cooldown.
                        else:
                             # Optional: Print statement for debugging, can be removed later
                             # if plate_text != last_detected_plate: # Only print if OCR result differs slightly
                             #    print(f"Ignoring '{plate_text}' (matches last processed: '{last_processed_plate}')")
                             #    last_detected_plate = plate_text # Update detected even if ignored
                             pass # Silently ignore

                    # Else (condition 1 fail): Still within the cooldown period after last action.
                    else:
                        # Update last detected plate if it changed slightly, even during cooldown
                        # if plate_text != last_detected_plate:
                        #    last_detected_plate = plate_text
                        pass # Don't process anything, still cooling down

                # Else (OCR returned empty string): No valid text found on the potential plate image.
                # Keep last_detection_time updated from when the *contour* was found? Or only when OCR is non-empty?
                # Let's update only on non-empty OCR (as done above).
                pass

            # --- End of processing extracted plate ---


            # --- Reset Logic: If NO plate contour found for a while, reset the 'processed' lock ---
            if not plate_found:
                # Check if enough time has passed since the last time *any* plate was *detected*
                if current_time - last_detection_time > reset_timeout:
                    if last_processed_plate != "": # Only reset if there's something to reset
                        print(f"\nNo plate detected for {reset_timeout}s. Resetting lock for '{last_processed_plate}'.")
                        last_processed_plate = ""
                        last_detected_plate = "" # Also clear last detected
                        lcd_display("ANPR System", "Ready") # Ensure LCD is Ready
                        # Reset last_detection_time to prevent immediate re-resetting
                        # Set it far in the past, or to current time? Setting to current is simpler.
                        last_detection_time = current_time # Pretend detection just happened for timeout purpose


            # --- Small delay in main loop ---
            time.sleep(0.1) # Main loop sleep


    except KeyboardInterrupt:
        print("\nðŸ›‘ Ctrl+C detected. Shutting Down...")
    finally:
        print("Cleaning up resources...")
        # Ensure barrier is closed and buzzer off
        GPIO.output(BARRIER_PIN, GPIO.LOW)
        GPIO.output(BUZZ_PIN, GPIO.LOW)
        lcd_display("System Stopped", "")
        time.sleep(1)
        if lcd_ready:
             try: lcd.clear()
             except Exception: pass
        picam2.stop()
        print("Camera stopped.")
        GPIO.cleanup()
        print("GPIO Cleaned Up. Exiting.")


# --- Initialization Checks ---
if __name__ == "__main__":
    try:
        tesseract_version = pytesseract.get_tesseract_version()
        print(f"Tesseract version: {tesseract_version}")
    except pytesseract.TesseractNotFoundError:
        # (Error message as before) ...
        exit(1)

    try:
        with open('Database.txt', 'r') as f:
             print("Database.txt found.")
    except FileNotFoundError:
         print("[WARNING] Database.txt not found.")
         try:
             with open('Database.txt', 'w') as f: print("  An empty Database.txt created.")
         except IOError as e: print(f"[ERROR] Could not create Database.txt: {e}")

    # --- Start Main Application ---
    main()
///////////////////////////

import cv2
import numpy as np
import pytesseract
import RPi.GPIO as GPIO
import time
from picamera2 import Picamera2
from RPLCD.gpio import CharLCD
import re # Import regex module for more flexible cleaning
import os # For creating debug directory

# ==================================
#        CONFIGURATION & TUNING
# ==================================
DEBUG_MODE = True            # Set to True to save intermediate images for debugging
DEBUG_IMG_PATH = "debug_images" # Folder to save debug images

# --- Camera ---
IMG_WIDTH = 1024
IMG_HEIGHT = 576

# --- Plate Extraction Tuning ---
CANNY_LOW_THRESH = 50       # Lower edge detection threshold (adjust based on lighting/contrast)
CANNY_HIGH_THRESH = 180      # Higher edge detection threshold
CONTOUR_APPROX_FACTOR = 0.02 # Contour approximation accuracy (smaller = more precise, larger = more lenient)
MIN_PLATE_AREA = 500        # Minimum pixel area for a contour to be considered a plate
MIN_ASPECT_RATIO = 1.8       # Minimum width/height ratio for a plate
MAX_ASPECT_RATIO = 5.5       # Maximum width/height ratio for a plate

# --- OCR Preprocessing Tuning ---
OCR_RESIZE_HEIGHT = 60       # Target height for the plate image before OCR
# Thresholding method ('ADAPTIVE' or 'OTSU')
THRESHOLD_METHOD = 'ADAPTIVE'
# Adaptive Threshold Params (if THRESHOLD_METHOD = 'ADAPTIVE')
ADAPT_THRESH_BLOCK_SIZE = 19 # Size of the neighborhood area (MUST be odd)
ADAPT_THRESH_C = 9           # Constant subtracted from the mean
# Morphology (Optional - uncomment and tune kernel size if needed)
# MORPH_OPEN_KERNEL = (3, 3) # Kernel size for MORPH_OPEN (removes small noise)
# MORPH_CLOSE_KERNEL = (3, 3)# Kernel size for MORPH_CLOSE (fills small gaps)

# --- Tesseract Tuning ---
TESS_LANG = 'eng'            # Language model for Tesseract
TESS_OEM = 3                 # OCR Engine Mode (3 is default LSTM)
TESS_PSM = '7'               # Page Segmentation Mode (7=single line, 6=block, 8=word, 13=raw line)
# Whitelist specific characters (HIGHLY RECOMMENDED if format is known)
# Example: UK plates (Letters A-Z, Numbers 0-9)
TESS_WHITELIST = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
# TESS_WHITELIST = "" # Leave empty to allow all characters

# --- OCR Post-Processing / Validation ---
MIN_PLATE_LENGTH = 5         # Minimum number of characters for a valid plate
# Regex pattern for expected plate format (Optional but recommended)
# Example: UK Format (2 letters, 2 numbers, 3 letters)
# EXPECTED_PLATE_PATTERN = r"^[A-Z]{2}[0-9]{2}[A-Z]{3}$"
EXPECTED_PLATE_PATTERN = "" # Leave empty to skip regex validation

# --- Main Loop Timing ---
PROCESS_COOLDOWN = 8       # Seconds to wait after an action (grant/deny) before processing ANY plate again
RESET_TIMEOUT = 15         # Seconds without ANY plate detection before resetting 'last_processed_plate'

# --- GPIO Pins ---
BUZZ_PIN = 18
BARRIER_PIN = 17
# LCD Pins (!! DOUBLE CHECK THESE !!)
LCD_RS = 7
LCD_E  = 8
LCD_D4 = 25
LCD_D5 = 24
LCD_D6 = 23
LCD_D7 = 12
# ==================================

# --- Create Debug Directory ---
if DEBUG_MODE and not os.path.exists(DEBUG_IMG_PATH):
    try:
        os.makedirs(DEBUG_IMG_PATH)
        print(f"Created debug directory: {DEBUG_IMG_PATH}")
    except OSError as e:
        print(f"[ERROR] Could not create debug directory '{DEBUG_IMG_PATH}': {e}")
        DEBUG_MODE = False # Disable debug if directory fails

# --- GPIO Setup ---
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)
GPIO.setup(BUZZ_PIN, GPIO.OUT, initial=GPIO.LOW)
GPIO.setup(BARRIER_PIN, GPIO.OUT, initial=GPIO.LOW)

# --- LCD 1602A Setup ---
try:
    lcd = CharLCD(
        numbering_mode=GPIO.BCM,
        cols=16, rows=2,
        pin_rs=LCD_RS, pin_e=LCD_E, pins_data=[LCD_D4, LCD_D5, LCD_D6, LCD_D7],
        charmap='A00', auto_linebreaks=True
    )
    lcd.clear()
    lcd_ready = True
    print("LCD Initialized Successfully.")
except Exception as e:
    print(f"[ERROR] Failed to initialize LCD: {e}")
    lcd_ready = False
    class DummyLCD: # Define dummy functions if init fails
        def write_string(self, text): pass
        def clear(self): pass
        def cursor_pos(self, pos): pass
    lcd = DummyLCD()

# --- PiCamera2 Setup ---
try:
    picam2 = Picamera2()
    config = picam2.create_preview_configuration(main={"size": (IMG_WIDTH, IMG_HEIGHT)})
    picam2.configure(config)
    picam2.start()
    time.sleep(2.0) # Allow sensor to settle
    print("Camera Initialized.")
except Exception as e:
    print(f"[ERROR] Failed to initialize Camera: {e}")
    # Consider exiting if camera fails
    exit(1)

# --- Helper Function for Perspective Transform (Unchanged) ---
def order_points(pts):
    rect = np.zeros((4, 2), dtype="float32")
    s = pts.sum(axis=1)
    rect[0] = pts[np.argmin(s)]
    rect[2] = pts[np.argmax(s)]
    diff = np.diff(pts, axis=1)
    rect[1] = pts[np.argmin(diff)]
    rect[3] = pts[np.argmax(diff)]
    return rect

def perspective_transform(image, pts):
    rect = order_points(pts)
    (tl, tr, br, bl) = rect
    widthA = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))
    widthB = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))
    maxWidth = max(int(widthA), int(widthB))
    heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))
    heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))
    maxHeight = max(int(heightA), int(heightB))
    if maxWidth <= 0 or maxHeight <= 0: return None
    dst = np.array([
        [0, 0], [maxWidth - 1, 0],
        [maxWidth - 1, maxHeight - 1], [0, maxHeight - 1]], dtype="float32")
    M = cv2.getPerspectiveTransform(rect, dst)
    warped = cv2.warpPerspective(image, M, (maxWidth, maxHeight))
    return warped

# --- Image Processing Functions ---
def capture_image():
    try:
        frame = picam2.capture_array("main")
        # Picamera2 often gives RGB/RGBA, OpenCV expects BGR
        if frame.shape[2] == 4: # Handle RGBA if present
            frame = cv2.cvtColor(frame, cv2.COLOR_RGBA2BGR)
        else:
            frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
        return frame
    except Exception as e:
        print(f"[ERROR] Failed during image capture: {e}")
        return None

def plate_extraction(image):
    """Finds potential license plate contours and returns the warped perspective image."""
    if image is None or image.size == 0: return None

    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blur = cv2.bilateralFilter(gray, 11, 17, 17) # Good for edge preservation
    edges = cv2.Canny(blur, CANNY_LOW_THRESH, CANNY_HIGH_THRESH)

    if DEBUG_MODE:
        ts = int(time.time())
        cv2.imwrite(os.path.join(DEBUG_IMG_PATH, f"{ts}_01_edges.png"), edges)

    cnts, _ = cv2.findContours(edges.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    cnts = sorted(cnts, key=cv2.contourArea, reverse=True)[:10]

    plate_contour = None
    for c in cnts:
        perimeter = cv2.arcLength(c, True)
        approx = cv2.approxPolyDP(c, CONTOUR_APPROX_FACTOR * perimeter, True)

        if len(approx) == 4:
            (x, y, w, h) = cv2.boundingRect(approx)
            aspect_ratio = w / float(h) if h > 0 else 0
            area = cv2.contourArea(approx)

            if MIN_PLATE_AREA < area and MIN_ASPECT_RATIO < aspect_ratio < MAX_ASPECT_RATIO:
                plate_contour = approx
                if DEBUG_MODE:
                     # Draw contour on original for debugging
                     debug_frame = image.copy()
                     cv2.drawContours(debug_frame, [plate_contour], -1, (0, 255, 0), 2)
                     cv2.imwrite(os.path.join(DEBUG_IMG_PATH, f"{ts}_02_contour_found.png"), debug_frame)
                break

    if plate_contour is None:
        return None
    else:
        pts = plate_contour.reshape(4, 2)
        warped_plate = perspective_transform(gray, pts) # Use gray image for transform - sometimes better contrast

        if warped_plate is None or warped_plate.size == 0: return None

        if DEBUG_MODE:
            cv2.imwrite(os.path.join(DEBUG_IMG_PATH, f"{ts}_03_warped_plate.png"), warped_plate)

        return warped_plate


def ocr_processing(plate_image_gray):
    """Performs OCR on the extracted grayscale plate image."""
    if plate_image_gray is None or plate_image_gray.size == 0:
        return ""

    # --- Preprocessing ---
    # Resize (optional but can help consistency)
    try:
        h, w = plate_image_gray.shape[:2]
        aspect_ratio = w / h
        target_width = int(OCR_RESIZE_HEIGHT * aspect_ratio)
        if target_width > 0:
            plate_image_resized = cv2.resize(plate_image_gray, (target_width, OCR_RESIZE_HEIGHT), interpolation=cv2.INTER_LANCZOS4)
        else:
            plate_image_resized = plate_image_gray
    except Exception as e:
        print(f"[WARN] Resizing failed: {e}. Using original.")
        plate_image_resized = plate_image_gray

    # Thresholding
    if THRESHOLD_METHOD == 'ADAPTIVE':
        binary_plate = cv2.adaptiveThreshold(
            plate_image_resized, 255,
            cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV,
            ADAPT_THRESH_BLOCK_SIZE, ADAPT_THRESH_C
        )
    elif THRESHOLD_METHOD == 'OTSU':
        # Otsu often works better with slight blurring first
        blurred = cv2.GaussianBlur(plate_image_resized, (5, 5), 0)
        _, binary_plate = cv2.threshold(blurred, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
    else: # Default to adaptive if invalid method specified
         binary_plate = cv2.adaptiveThreshold(
            plate_image_resized, 255,
            cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV,
            ADAPT_THRESH_BLOCK_SIZE, ADAPT_THRESH_C
         )

    # Optional Morphology (Uncomment and tune if needed)
    # if 'MORPH_OPEN_KERNEL' in globals():
    #     kernel_open = np.ones(MORPH_OPEN_KERNEL, np.uint8)
    #     binary_plate = cv2.morphologyEx(binary_plate, cv2.MORPH_OPEN, kernel_open)
    # if 'MORPH_CLOSE_KERNEL' in globals():
    #     kernel_close = np.ones(MORPH_CLOSE_KERNEL, np.uint8)
    #     binary_plate = cv2.morphologyEx(binary_plate, cv2.MORPH_CLOSE, kernel_close)

    if DEBUG_MODE:
        ts = int(time.time())
        cv2.imwrite(os.path.join(DEBUG_IMG_PATH, f"{ts}_04_binary_plate.png"), binary_plate)

    # --- Tesseract OCR ---
    custom_config = f'--oem {TESS_OEM} --psm {TESS_PSM} -l {TESS_LANG}'
    if TESS_WHITELIST:
        custom_config += f' -c tessedit_char_whitelist={TESS_WHITELIST}'

    try:
        raw_text = pytesseract.image_to_string(binary_plate, config=custom_config)
        if DEBUG_MODE:
            print(f"  Raw Tesseract Output: '{raw_text.strip()}'")

        # --- OCR Cleanup & Validation ---
        # 1. Basic cleanup: Remove whitespace, convert to uppercase
        cleaned_text = ''.join(filter(str.isalnum, raw_text)).upper()

        # 2. Length check
        if len(cleaned_text) < MIN_PLATE_LENGTH:
            if DEBUG_MODE and cleaned_text: print(f"  Rejecting: Too short ('{cleaned_text}')")
            return ""

        # 3. Regex pattern check (if defined)
        if EXPECTED_PLATE_PATTERN:
            if not re.fullmatch(EXPECTED_PLATE_PATTERN, cleaned_text):
                if DEBUG_MODE: print(f"  Rejecting: Pattern mismatch ('{cleaned_text}')")
                # Optional: Add character substitution logic here before final rejection
                return ""

        # If all checks pass
        return cleaned_text

    except pytesseract.TesseractNotFoundError:
        print("[ERROR] Tesseract is not installed or not in your PATH.")
        # Consider adding a flag to stop the script if Tesseract isn't found
        return ""
    except Exception as e:
        print(f"[ERROR] OCR failed: {e}")
        return ""


def check_database(plate_text):
    """Checks if the cleaned plate text exists in the database file."""
    if not plate_text: return False
    try:
        with open('Database.txt', 'r') as f:
            # Read lines, strip whitespace, convert to upper, ignore empty lines
            database_plates = {line.strip().upper() for line in f if line.strip()}
        return plate_text in database_plates
    except FileNotFoundError:
        print("[ERROR] Database.txt file not found!")
        # Attempt to create it
        try:
            with open('Database.txt', 'w') as f: pass
            print("[INFO] Created empty Database.txt")
        except IOError:
            print("[ERROR] Could not create Database.txt")
        return False
    except Exception as e:
        print(f"[ERROR] Error reading database: {e}")
        return False


def control_barrier(state):
    """Controls the barrier GPIO pin."""
    if state in [GPIO.HIGH, GPIO.LOW]:
        GPIO.output(BARRIER_PIN, state)
    else:
        print(f"[WARN] Invalid state '{state}' for barrier control.")


def lcd_display(line1, line2=""):
    """Displays text on the LCD, handling potential errors."""
    if not lcd_ready: return
    try:
        lcd.clear()
        lcd.cursor_pos = (0, 0)
        lcd.write_string(str(line1)[:16]) # Truncate to 16 chars
        if line2:
            lcd.cursor_pos = (1, 0)
            lcd.write_string(str(line2)[:16]) # Truncate to 16 chars
    except Exception as e:
        print(f"[ERROR] Failed to write to LCD: {e}")


# ========================
#        MAIN FUNCTION
# ========================
def main():
    print("ðŸš— ANPR System Started...")
    print("Tuning Parameters:")
    print(f"  - Canny: {CANNY_LOW_THRESH}/{CANNY_HIGH_THRESH}, Approx: {CONTOUR_APPROX_FACTOR}")
    print(f"  - Plate Area: >{MIN_PLATE_AREA}, Aspect: {MIN_ASPECT_RATIO}-{MAX_ASPECT_RATIO}")
    print(f"  - Threshold: {THRESHOLD_METHOD} (Block: {ADAPT_THRESH_BLOCK_SIZE}, C: {ADAPT_THRESH_C} if Adaptive)")
    print(f"  - Tesseract: PSM={TESS_PSM}, Whitelist='{TESS_WHITELIST}', MinLen={MIN_PLATE_LENGTH}")
    print(f"  - Timers: Cooldown={PROCESS_COOLDOWN}s, Reset={RESET_TIMEOUT}s")
    print(f"  - Debug Mode: {'ON' if DEBUG_MODE else 'OFF'}")
    print("Press Ctrl+C in this terminal to Quit.")

    lcd_display("ANPR System", "Initializing...")
    time.sleep(1)
    lcd_display("ANPR System", "Ready")

    # State variables
    last_processed_plate = ""  # Stores the plate that triggered the last action
    last_process_time = 0      # Timestamp when the last action (grant/deny) occurred
    last_detection_time = 0    # Timestamp of the last time *any* plate contour was found

    try:
        while True:
            current_time = time.time()
            frame_color = capture_image() # Capture in color first
            if frame_color is None:
                print("[WARN] Failed to capture frame.")
                time.sleep(0.5)
                continue

            plate_found_this_cycle = False # Reset flag each loop
            extracted_plate_img_gray = plate_extraction(frame_color) # Pass color frame

            # --- Process only if a potential plate region was extracted ---
            if extracted_plate_img_gray is not None:
                plate_found_this_cycle = True
                last_detection_time = current_time # Update time whenever a contour is found

                plate_text = ocr_processing(extracted_plate_img_gray) # Pass the extracted GRAY plate

                # --- Process only if OCR returned a valid plate text ---
                if plate_text:
                    # Condition 1: Has cooldown period passed since last action?
                    if current_time - last_process_time > PROCESS_COOLDOWN:
                        # Condition 2: Is this plate different from the one last processed?
                        if plate_text != last_processed_plate:
                            print(f"\nDetected Plate: '{plate_text}'", end=' ')
                            lcd_display("Plate: " + plate_text, "Checking...")

                            # Perform Database Check and Actions
                            if check_database(plate_text):
                                print("[REGISTERED] âœ… Access Granted!")
                                lcd_display(plate_text, "Access Granted")
                                GPIO.output(BUZZ_PIN, GPIO.HIGH)
                                control_barrier(GPIO.HIGH)      # Open
                                time.sleep(0.5)                 # Buzzer duration
                                GPIO.output(BUZZ_PIN, GPIO.LOW)
                                time.sleep(4)                   # Barrier open duration
                                control_barrier(GPIO.LOW)       # Close
                                print(f"-> Processed '{plate_text}'. Starting cooldown.")
                            else: # Access Denied
                                print("[UNREGISTERED] âŒ Access Denied!")
                                lcd_display(plate_text, "Access Denied")
                                for _ in range(3): # Short buzzes
                                    GPIO.output(BUZZ_PIN, GPIO.HIGH); time.sleep(0.1)
                                    GPIO.output(BUZZ_PIN, GPIO.LOW); time.sleep(0.1)
                                time.sleep(1.5) # Show denied message on LCD
                                print(f"-> Processed '{plate_text}'. Starting cooldown.")

                            # === Mark plate as processed and record time ===
                            last_processed_plate = plate_text
                            last_process_time = current_time # Start cooldown timer

                            # Short delay and update LCD after action
                            time.sleep(0.5)
                            lcd_display("ANPR System", "Ready")

                        # Else (condition 2 fail): Same plate as last processed. Ignore.
                        else:
                            if DEBUG_MODE: print(f". (Ignoring repeat '{plate_text}')")
                            pass # Silently ignore during cooldown or if same as last processed

                    # Else (condition 1 fail): Still within cooldown.
                    else:
                         if DEBUG_MODE: print(f". (Cooldown active, ignoring '{plate_text}')")
                         pass # Don't process anything

                # Else (OCR returned empty string): Valid contour, but no text extracted.
                else:
                    if DEBUG_MODE: print(". (Contour found, no valid OCR text)")
                    pass

            # --- End of processing extracted plate ---

            # --- Reset Logic: If NO plate contour found for a while ---
            if not plate_found_this_cycle:
                # Check if enough time has passed since the last time *any* contour was detected
                if current_time - last_detection_time > RESET_TIMEOUT:
                    if last_processed_plate != "": # Only reset if there was a previously processed plate
                        print(f"\nNo plate detected for {RESET_TIMEOUT}s. Resetting process lock.")
                        last_processed_plate = ""
                        lcd_display("ANPR System", "Ready") # Ensure LCD is Ready
                        # Prevent immediate re-resetting by updating detection time
                        last_detection_time = current_time

            # --- Small delay in main loop ---
            time.sleep(0.1) # Adjust as needed for CPU usage / responsiveness trade-off

    except KeyboardInterrupt:
        print("\nðŸ›‘ Ctrl+C detected. Shutting Down...")
    finally:
        print("Cleaning up resources...")
        GPIO.output(BARRIER_PIN, GPIO.LOW) # Ensure barrier closed
        GPIO.output(BUZZ_PIN, GPIO.LOW)    # Ensure buzzer off
        lcd_display("System Stopped", "")
        time.sleep(0.5)
        if lcd_ready:
             try: lcd.clear()
             except Exception: pass
        try:
            picam2.stop()
            print("Camera stopped.")
        except Exception as e:
            print(f"Error stopping camera: {e}")
        GPIO.cleanup()
        print("GPIO Cleaned Up. Exiting.")

# --- Initialization Checks ---
if __name__ == "__main__":
    # Check Tesseract Installation
    try:
        tesseract_version = pytesseract.get_tesseract_version()
        print(f"Tesseract version: {tesseract_version}")
    except pytesseract.TesseractNotFoundError:
        print("="*40)
        print("[FATAL ERROR] Tesseract is not installed or not found in your system's PATH.")
        print("Please install Tesseract OCR:")
        print("  On Debian/Ubuntu/Raspberry Pi OS: sudo apt update && sudo apt install tesseract-ocr")
        print("  Ensure the 'tesseract' command works in your terminal.")
        print("="*40)
        exit(1) # Exit if Tesseract is missing

    # Check Database File
    try:
        with open('Database.txt', 'r') as f:
             db_lines = len(f.readlines())
             print(f"Database.txt found with {db_lines} entries.")
    except FileNotFoundError:
         print("[WARNING] Database.txt not found.")
         try:
             with open('Database.txt', 'w') as f: print("  -> Created empty Database.txt.")
         except IOError as e: print(f"[ERROR] Could not create Database.txt: {e}")

    # --- Start Main Application ---
    main()
