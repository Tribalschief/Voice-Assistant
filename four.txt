import cv2
import numpy as np
import pytesseract
# GPIO and LCD specific imports are removed or handled with try-except
import time
import re
import os

# --- Configuration Constants ---
DEBUG = True  # Set to True to save intermediate images for debugging
DEBUG_PATH = "debug_images"

# Plate Extraction (Can be tuned)
CANNY_LOW_THRESHOLD = 50
CANNY_HIGH_THRESHOLD = 150
CONTOUR_CANDIDATES = 20
APPROX_EPSILON = 0.02
MIN_PLATE_ASPECT_RATIO = 1.2
MAX_PLATE_ASPECT_RATIO = 6.0
MIN_PLATE_AREA = 150

# OCR Processing
OCR_TARGET_HEIGHT = 60
ADAPTIVE_THRESH_BLOCK_SIZE = 19
ADAPTIVE_THRESH_C = 9
TESSERACT_PSM = 6 # Try 6 (uniform block), 7 (single line), 8 (single word)
MIN_PLATE_TEXT_LENGTH = 3
TESSERACT_CHAR_WHITELIST = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

# Global variable for the webcam capture object
cap = None
plate_contour_for_drawing = None # To store the contour for drawing on the main frame

# --- Dummy Hardware Functions (if specific hardware isn't present) ---
class DummyGPIO:
    HIGH = 1
    LOW = 0
    OUT = 1
    BCM = 11
    def setup(self, pin, mode): pass
    def output(self, pin, state): pass
    def cleanup(self): pass
    def setwarnings(self, val): pass
    def setmode(self, val): pass

class DummyLCD:
    def write_string(self, text): pass
    def clear(self): pass
    def cursor_pos(self, pos): pass

# Attempt to use real GPIO if available, otherwise use dummy
try:
    import RPi.GPIO as GPIO
    GPIO.setwarnings(False)
    GPIO.setmode(GPIO.BCM)
    gpio_available = True
    print("Real RPi.GPIO imported.")
    # Define BUZZ_PIN and BARRIER_PIN if you intend to use them on a Pi and setup them
    # BUZZ_PIN = 18
    # BARRIER_PIN = 17
    # GPIO.setup(BUZZ_PIN, GPIO.OUT)
    # GPIO.setup(BARRIER_PIN, GPIO.OUT)
except (ImportError, RuntimeError):
    print("RPi.GPIO not found or failed to initialize. Using DummyGPIO.")
    GPIO = DummyGPIO()
    gpio_available = False

# Attempt to use real LCD if available, otherwise use dummy
try:
    from RPLCD.gpio import CharLCD
    if not gpio_available: raise ImportError("GPIO not available for LCD")
    # Define LCD pins if you intend to use them
    lcd = CharLCD(
        numbering_mode=GPIO.BCM, cols=16, rows=2,
        pin_rs=7, pin_e=8, pins_data=[25, 24, 23, 12] # Example pins
    )
    lcd.clear()
    lcd_available = True
    print("Real RPLCD.gpio.CharLCD initialized.")
except (ImportError, RuntimeError, NameError):
    print("RPLCD.gpio not found or failed to initialize. Using DummyLCD.")
    lcd = DummyLCD()
    lcd_available = False


# --- Debugging Helper ---
if DEBUG:
    if not os.path.exists(DEBUG_PATH):
        try:
            os.makedirs(DEBUG_PATH)
            print(f"Created debug directory: {DEBUG_PATH}")
        except OSError as e:
            print(f"[ERROR] Could not create debug directory {DEBUG_PATH}: {e}. Debug images disabled.")
            DEBUG = False

def save_debug_image(name, image_data):
    if DEBUG and image_data is not None and image_data.size > 0:
        try:
            cv2.imwrite(os.path.join(DEBUG_PATH, name), image_data)
            print(f"[DEBUG] Saved image: {name}")
        except Exception as e:
            print(f"[DEBUG-ERROR] Could not save {name}: {e}")

# --- Helper Function for Perspective Transform ---
def order_points(pts):
    rect = np.zeros((4, 2), dtype="float32")
    s = pts.sum(axis=1)
    rect[0] = pts[np.argmin(s)]
    rect[2] = pts[np.argmax(s)]
    diff = np.diff(pts, axis=1)
    rect[1] = pts[np.argmin(diff)]
    rect[3] = pts[np.argmax(diff)]
    return rect

def perspective_transform(image, pts):
    rect = order_points(pts)
    (tl, tr, br, bl) = rect
    widthA = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))
    widthB = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))
    maxWidth = max(int(widthA), int(widthB))
    heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))
    heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))
    maxHeight = max(int(heightA), int(heightB))
    if maxWidth <= 0 or maxHeight <= 0:
        print("[WARN] Invalid dimensions for perspective transform.")
        return None
    dst = np.array([[0, 0], [maxWidth - 1, 0], [maxWidth - 1, maxHeight - 1], [0, maxHeight - 1]], dtype="float32")
    M = cv2.getPerspectiveTransform(rect, dst)
    warped = cv2.warpPerspective(image, M, (maxWidth, maxHeight))
    return warped

# --- Image Processing Functions ---
def capture_image_from_webcam():
    global cap # Use the global webcam capture object
    if cap and cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            print("[ERROR] Failed to grab frame from webcam.")
            return None
        return frame
    else:
        print("[ERROR] Webcam not available or not opened.")
        return None

def plate_extraction(image):
    global plate_contour_for_drawing
    plate_contour_for_drawing = None # Reset for each frame

    if image is None or image.size == 0: return None
    save_debug_image("0_plate_extraction_input.png", image)

    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    save_debug_image("1_gray.png", gray)

    blur = cv2.bilateralFilter(gray, d=9, sigmaColor=75, sigmaSpace=75)
    save_debug_image("2_blur.png", blur)

    edges = cv2.Canny(blur, CANNY_LOW_THRESHOLD, CANNY_HIGH_THRESHOLD)
    save_debug_image("3_edges.png", edges)

    cnts, _ = cv2.findContours(edges.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    if not cnts: return None
    cnts = sorted(cnts, key=cv2.contourArea, reverse=True)[:CONTOUR_CANDIDATES]

    extracted_plate_img = None

    for c in cnts:
        perimeter = cv2.arcLength(c, True)
        approx = cv2.approxPolyDP(c, APPROX_EPSILON * perimeter, True)
        num_points = len(approx)

        if num_points >= 4:
            (x, y, w, h) = cv2.boundingRect(approx)
            aspect_ratio = w / float(h) if h > 0 else 0
            area = cv2.contourArea(approx)

            if (MIN_PLATE_ASPECT_RATIO <= aspect_ratio <= MAX_PLATE_ASPECT_RATIO and
                area > MIN_PLATE_AREA):
                plate_contour_for_drawing = approx

                if num_points == 4:
                    pts = approx.reshape(4, 2)
                    warped = perspective_transform(image, pts)
                    if warped is not None and warped.size > 0:
                        save_debug_image("7_warped_plate.png", warped)
                        extracted_plate_img = warped
                        break
                else:
                    print(f"[WARN] Contour has {num_points} points, not 4. Using bounding box crop.")
                    x_br, y_br, w_br, h_br = cv2.boundingRect(approx)
                    cropped = image[y_br:y_br+h_br, x_br:x_br+w_br]
                    if cropped.size > 0:
                        save_debug_image("7_crude_crop_no_warp.png", cropped)
                        extracted_plate_img = cropped
                        break
    return extracted_plate_img


def ocr_processing(plate_image):
    if plate_image is None or plate_image.size == 0: return ""
    save_debug_image("8_ocr_input_plate.png", plate_image)

    target_height = OCR_TARGET_HEIGHT
    h, w = plate_image.shape[:2]
    if h == 0 or w == 0: return ""
    aspect_ratio = w / float(h)
    target_width = int(target_height * aspect_ratio)
    plate_image_resized = plate_image
    if target_width > 0 and target_height > 0:
        try:
            plate_image_resized = cv2.resize(plate_image, (target_width, target_height), interpolation=cv2.INTER_LANCZOS4)
            save_debug_image("9_ocr_resized.png", plate_image_resized)
        except cv2.error: pass

    gray_plate = cv2.cvtColor(plate_image_resized, cv2.COLOR_BGR2GRAY)
    save_debug_image("10_ocr_gray.png", gray_plate)

    binary_plate = cv2.adaptiveThreshold(
        gray_plate, 255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV,
        ADAPTIVE_THRESH_BLOCK_SIZE, ADAPTIVE_THRESH_C
    )
    save_debug_image("11_ocr_binary_plate.png", binary_plate)

    custom_config = f'--oem 3 --psm {TESSERACT_PSM}'
    if TESSERACT_CHAR_WHITELIST:
        custom_config += f' -c tessedit_char_whitelist={TESSERACT_CHAR_WHITELIST}'

    try:
        text = pytesseract.image_to_string(binary_plate, config=custom_config)
        cleaned_text = ''.join(filter(str.isalnum, text.strip())).upper()
        if len(cleaned_text) < MIN_PLATE_TEXT_LENGTH:
            return ""
        print(f"[OCR] Detected: '{cleaned_text}' (Raw: '{text.strip()}')")
        return cleaned_text
    except pytesseract.TesseractNotFoundError:
        print("[ERROR] Tesseract is not installed or not in PATH.")
        return "TESS_ERR"
    except Exception as e:
        print(f"[ERROR] OCR failed: {e}")
        return ""

def check_database(plate_text):
    if not plate_text or plate_text == "TESS_ERR": return False
    try:
        with open('Database.txt', 'r') as f:
            database_plates = {line.strip().upper() for line in f if line.strip()}
        return plate_text in database_plates
    except FileNotFoundError:
        print("[ERROR] Database.txt not found.")
        try:
            with open('Database.txt', 'w') as f: pass
        except IOError: print("[ERROR] Could not create Database.txt")
        return False
    except Exception as e:
        print(f"[ERROR] Error reading database: {e}")
        return False

# ========================
#        MAIN FUNCTION
# ========================
def main():
    global cap, plate_contour_for_drawing

    print("ðŸš— ANPR System Started...")
    lcd.clear()
    lcd.write_string("ANPR System")
    lcd.cursor_pos = (1,0)
    lcd.write_string("Initializing...")

    cap = cv2.VideoCapture(0) # 0 for default webcam
    if not cap.isOpened():
        print("[FATAL ERROR] Cannot open webcam.")
        lcd.cursor_pos = (1,0)
        lcd.write_string("Webcam Error")
        return
    print("Webcam initialized successfully.")

    time.sleep(1.0) # Allow webcam to settle
    lcd.cursor_pos = (1,0)
    lcd.write_string("Ready         ") # Pad with spaces to clear previous longer messages

    last_processed_plate = ""
    last_process_time = 0
    process_cooldown = 5 # Seconds to wait after an action

    running = True
    while running:
        current_time = time.time()
        frame = capture_image_from_webcam()

        if frame is None:
            time.sleep(0.1) # Wait a bit if frame capture failed
            continue

        # --- ANPR Processing ---
        # Process on a copy if you want to keep the original frame clean
        # processing_frame = frame.copy()
        # extracted_plate_img = plate_extraction(processing_frame)
        extracted_plate_img = plate_extraction(frame) # Process directly on the frame for now
        ocr_text_result = ""

        if extracted_plate_img is not None:
            if plate_contour_for_drawing is not None:
                cv2.drawContours(frame, [plate_contour_for_drawing], -1, (0, 255, 0), 2)

            ocr_text_result = ocr_processing(extracted_plate_img)

            if ocr_text_result and ocr_text_result != "TESS_ERR":
                if plate_contour_for_drawing is not None:
                    x_c, y_c, _, _ = cv2.boundingRect(plate_contour_for_drawing)
                    cv2.putText(frame, ocr_text_result, (x_c, y_c - 10),
                                cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0,0,255), 2, cv2.LINE_AA)
                else:
                    cv2.putText(frame, ocr_text_result, (30, 50),
                                cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0,0,255), 2, cv2.LINE_AA)

                if (current_time - last_process_time > process_cooldown) and \
                   (ocr_text_result != last_processed_plate):

                    lcd.clear()
                    lcd.write_string(ocr_text_result[:16])
                    lcd.cursor_pos = (1,0)
                    lcd.write_string("Checking DB...")
                    print(f"Processing new plate: {ocr_text_result}")

                    if check_database(ocr_text_result):
                        print(f"[ACCESS GRANTED] Plate: {ocr_text_result}")
                        lcd.cursor_pos = (1,0)
                        lcd.write_string("Access Granted!")
                        # Simulate barrier open (GPIO is dummied if not available)
                        # GPIO.output(BARRIER_PIN_ID, GPIO.HIGH) # Define BARRIER_PIN_ID
                        # time.sleep(0.2)
                        # GPIO.output(BARRIER_PIN_ID, GPIO.LOW)
                    else:
                        print(f"[ACCESS DENIED] Plate: {ocr_text_result}")
                        lcd.cursor_pos = (1,0)
                        lcd.write_string("Access Denied ") # Pad for clearing
                        # Simulate buzzer (GPIO is dummied if not available)
                        # GPIO.output(BUZZER_PIN_ID, GPIO.HIGH) # Define BUZZER_PIN_ID
                        # time.sleep(0.2)
                        # GPIO.output(BUZZER_PIN_ID, GPIO.LOW)

                    last_processed_plate = ocr_text_result
                    last_process_time = current_time
                    time.sleep(1) # Display message on LCD
                    lcd.cursor_pos = (1,0)
                    lcd.write_string("Ready          ")

            elif ocr_text_result == "TESS_ERR":
                 cv2.putText(frame, "TESSERACT ERROR", (30, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2, cv2.LINE_AA)
                 lcd.cursor_pos = (1,0)
                 lcd.write_string("OCR Error     ")

        # --- Display frame ---
        cv2.imshow("ANPR System Feed", frame)
        key = cv2.waitKey(1) & 0xFF
        if key == ord('q'):
            running = False

    # --- Cleanup ---
    print("Shutting down...")
    if cap:
        cap.release()
    cv2.destroyAllWindows()
    lcd.clear()
    lcd.write_string("System OFFLINE")
    if gpio_available : GPIO.cleanup()
    print("Cleanup complete. Exited.")

# --- Initialization Checks ---
if __name__ == "__main__":
    try:
        tesseract_version = pytesseract.get_tesseract_version()
        print(f"Tesseract version: {tesseract_version}")
    except pytesseract.TesseractNotFoundError:
        print("[FATAL ERROR] Tesseract is not installed or not found in PATH.")
        print("Ensure Tesseract is installed and its directory is in your system's PATH environment variable.")
        exit(1)
    except Exception as e:
        print(f"[ERROR] Could not get Tesseract version: {e}")

    if not os.path.exists('Database.txt'):
        print("[INFO] Database.txt not found. Creating empty file.")
        try:
            with open('Database.txt', 'w') as f: pass
        except IOError as e: print(f"[ERROR] Could not create Database.txt: {e}")

    main()
