import cv2
import numpy as np
import pytesseract
import RPi.GPIO as GPIO
import time
from picamera2 import Picamera2
from RPLCD.gpio import CharLCD
import re # Import regex module for more flexible cleaning

# --- GPIO Setup ---
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)

BUZZ_PIN = 18
BARRIER_PIN = 17
GPIO.setup(BUZZ_PIN, GPIO.OUT)
GPIO.setup(BARRIER_PIN, GPIO.OUT)
GPIO.output(BARRIER_PIN, GPIO.LOW) # Ensure barrier is closed at start
GPIO.output(BUZZ_PIN, GPIO.LOW)   # Ensure buzzer is off at start

# --- LCD 1602A Setup (Without I2C) ---
# !! DOUBLE CHECK THESE PINS MATCH YOUR WIRING !!
try:
    lcd = CharLCD(
        numbering_mode=GPIO.BCM,
        cols=16,
        rows=2,
        pin_rs=7,
        pin_e=8,
        pins_data=[25, 24, 23, 12],
        charmap='A00', # Standard European character map (only affects LCD display, not OCR)
        auto_linebreaks=True
    )
    lcd.clear() # Clear display on startup
    lcd_ready = True
    print("LCD Initialized Successfully.")
except Exception as e:
    print(f"[ERROR] Failed to initialize LCD: {e}")
    print("Check GPIO connections and RPLCD installation.")
    lcd_ready = False
    # Define dummy lcd functions if init fails to avoid errors later
    class DummyLCD:
        def write_string(self, text): pass
        def clear(self): pass
        def cursor_pos(self, pos): pass
    lcd = DummyLCD()


# --- PiCamera2 Setup ---
picam2 = Picamera2()
# Consider image size trade-offs:
# Smaller (e.g., 640, 480): Faster processing, lower resolution for distant plates.
# Larger (e.g., 1280, 720): Slower processing, better detail. (1024, 576) is a good compromise.
picam2.configure(picam2.create_preview_configuration(main={"size": (1024, 576)}))
picam2.start()
# Allow camera sensor to settle
time.sleep(2.0)
print("Camera Initialized.")


# --- Helper Function for Perspective Transform ---
# (Keep this function as is, it's standard geometry)
def order_points(pts):
    rect = np.zeros((4, 2), dtype="float32")
    s = pts.sum(axis=1)
    rect[0] = pts[np.argmin(s)]
    rect[2] = pts[np.argmax(s)]
    diff = np.diff(pts, axis=1)
    rect[1] = pts[np.argmin(diff)]
    rect[3] = pts[np.argmax(diff)]
    return rect

def perspective_transform(image, pts):
    rect = order_points(pts)
    (tl, tr, br, bl) = rect
    widthA = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))
    widthB = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))
    maxWidth = max(int(widthA), int(widthB))
    heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))
    heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))
    maxHeight = max(int(heightA), int(heightB))

    # Make sure dimensions are valid before creating dst array
    if maxWidth <= 0 or maxHeight <= 0:
        print("[WARN] Invalid dimensions calculated for perspective transform.")
        return None # Return None if dimensions are invalid

    dst = np.array([
        [0, 0],
        [maxWidth - 1, 0],
        [maxWidth - 1, maxHeight - 1],
        [0, maxHeight - 1]], dtype="float32")

    M = cv2.getPerspectiveTransform(rect, dst)
    warped = cv2.warpPerspective(image, M, (maxWidth, maxHeight))
    return warped

# --- Image Processing Functions ---
def capture_image():
    # Capture frame as numpy array BGR format
    frame = picam2.capture_array("main")
    # Picamera2 usually gives RGB, OpenCV expects BGR.
    # Double-check this: If colors look swapped (blue/red), uncomment the line below.
    frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR) # UNCOMMENTED based on common picam2 usage
    return frame

def plate_extraction(image):
    if image is None or image.size == 0: return None # Add check for valid input image

    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blur = cv2.bilateralFilter(gray, 11, 17, 17)
    edges = cv2.Canny(blur, 30, 180) # Wider range might catch plates in varying light
                                     # TUNE THIS: Low threshold (30) / High threshold (180)

    cnts, _ = cv2.findContours(edges.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    cnts = sorted(cnts, key=cv2.contourArea, reverse=True)[:10] # Check top 10

    plate_contour = None
    for c in cnts:
        perimeter = cv2.arcLength(c, True)
        epsilon = 0.018 # TUNE THIS: Approximation accuracy
        approx = cv2.approxPolyDP(c, epsilon * perimeter, True)

        if len(approx) == 4:
            # Basic Aspect Ratio and Area Check (optional but recommended)
            (x, y, w, h) = cv2.boundingRect(approx)
            aspect_ratio = w / float(h) if h > 0 else 0
            area = cv2.contourArea(approx)

            # Adjust these min/max values based on expected plate size/distance in your setup
            min_aspect_ratio = 1.5
            max_aspect_ratio = 5.5
            min_area = 400 # Minimum pixel area to reduce noise

            if aspect_ratio >= min_aspect_ratio and aspect_ratio <= max_aspect_ratio and area > min_area:
                plate_contour = approx
                break # Found a plausible plate

    if plate_contour is None:
        return None
    else:
        pts = plate_contour.reshape(4, 2)
        warped_plate = perspective_transform(image, pts) # Use color image

        if warped_plate is None or warped_plate.size == 0:
             return None

        return warped_plate

def ocr_processing(plate_image):
    if plate_image is None or plate_image.size == 0:
        return ""

    target_height = 60
    aspect_ratio = plate_image.shape[1] / plate_image.shape[0]
    target_width = int(target_height * aspect_ratio)
    if target_width > 0 and target_height > 0:
         try:
            plate_image_resized = cv2.resize(plate_image, (target_width, target_height), interpolation=cv2.INTER_LANCZOS4)
         except cv2.error:
             plate_image_resized = plate_image # Use original if resize fails
    else:
        plate_image_resized = plate_image # Use original if dims invalid

    gray_plate = cv2.cvtColor(plate_image_resized, cv2.COLOR_BGR2GRAY)
    # No blur initially often works ok with adaptive threshold
    # blurred_plate = cv2.GaussianBlur(gray_plate, (3, 3), 0)

    binary_plate = cv2.adaptiveThreshold(
        gray_plate, # Use gray directly
        255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY_INV,
        19, # TUNE THIS: Block Size (try larger if chars are thick)
        9   # TUNE THIS: Constant C (increase if too much noise included, decrease if chars broken)
    )

    # --- Tesseract OCR ---
    # TUNE THIS: PSM mode (7: single line, 8: single word, 6: uniform block, 11: sparse)
    custom_config = r'--oem 3 --psm 7'

    try:
        text = pytesseract.image_to_string(binary_plate, config=custom_config)

        # --- OCR Cleanup ---
        cleaned_text = text.strip()
        # Basic alphanumeric cleanup + uppercase
        cleaned_text = ''.join(filter(str.isalnum, cleaned_text)).upper()
        # Example more advanced cleanup (remove leading/trailing non-letters/numbers)
        # cleaned_text = re.sub(r'^[^A-Z0-9]+|[^A-Z0-9]+$', '', cleaned_text)

        # TUNE THIS: Minimum plate length
        if len(cleaned_text) < 4:
            return ""

        return cleaned_text
    except pytesseract.TesseractNotFoundError:
        print("[ERROR] Tesseract is not installed or not in your PATH.")
        return ""
    except Exception as e:
        print(f"[ERROR] OCR failed: {e}")
        return ""


def check_database(plate_text):
    if not plate_text:
        return False
    try:
        with open('Database.txt', 'r') as f:
            database_plates = {line.strip().upper() for line in f if line.strip()}
            return plate_text in database_plates
    except FileNotFoundError:
        print("[ERROR] Database.txt file not found!")
        try:
             with open('Database.txt', 'w') as f: pass # Create empty
             print("[WARN] Created empty Database.txt")
        except IOError: print("[ERROR] Could not create Database.txt")
        return False
    except Exception as e:
        print(f"[ERROR] Error reading database: {e}")
        return False


def control_barrier(state):
    if state in [GPIO.HIGH, GPIO.LOW]:
        GPIO.output(BARRIER_PIN, state)
    else:
        print(f"[WARN] Invalid state '{state}' for barrier control.")


def lcd_display(line1, line2=""):
    if not lcd_ready: return
    try:
        lcd.clear()
        lcd.cursor_pos = (0, 0)
        lcd.write_string(str(line1)[:16])
        if line2:
            lcd.cursor_pos = (1, 0)
            lcd.write_string(str(line2)[:16])
    except Exception as e:
        print(f"[ERROR] Failed to write to LCD: {e}")


# ========================
#        MAIN FUNCTION
# ========================
def main():
    print("🚗 ANPR System Started...")
    print("Press Ctrl+C in this terminal to Quit.")
    lcd_display("ANPR System", "Initializing...")
    time.sleep(1)
    lcd_display("ANPR System", "Ready")

    last_detected_plate = ""     # Stores the most recent OCR result string
    last_processed_plate = ""  # << NEW: Stores the plate that triggered the last action
    last_detection_time = 0    # Timestamp of the last time *any* plate was detected by OCR
    last_process_time = 0      # << NEW: Timestamp when the last action (grant/deny) occurred
    # TUNE THESE: Delays and Timeouts
    debounce_display_time = 1  # Seconds before showing the same detected plate again in console/LCD
    process_cooldown = 10      # << NEW: Seconds to wait *after* an action before processing ANY plate again
    reset_timeout = 15         # << NEW: Seconds without ANY plate detection before resetting 'last_processed_plate'

    try:
        while True:
            current_time = time.time()
            frame = capture_image()
            if frame is None:
                print("[WARN] Failed to capture frame.")
                time.sleep(0.5)
                continue

            plate_found = False # Flag to track if *any* plate contour was found this frame
            extracted_plate_img = plate_extraction(frame)

            # --- Process only if a plate region was extracted ---
            if extracted_plate_img is not None:
                plate_found = True
                plate_text = ocr_processing(extracted_plate_img)

                # --- Process only if OCR returned a valid-looking plate ---
                if plate_text:
                    last_detection_time = current_time # Update time whenever OCR finds something

                    # --- Condition 1: Has enough time passed since the *last action*? ---
                    if current_time - last_process_time > process_cooldown:

                        # --- Condition 2: Is this plate different from the one last *processed*? ---
                        if plate_text != last_processed_plate:

                            # --- Condition 3 (Display Debounce): Is it different from last *detection* OR enough time passed? ---
                            # This prevents console/LCD spam if OCR flickers briefly before stabilizing on the NEW plate.
                            if plate_text != last_detected_plate or (current_time - last_detection_time > debounce_display_time):
                                print(f"Detected Plate: '{plate_text}'", end=' ')
                                lcd_display("Plate: " + plate_text, "Checking...")
                                # Update last_detected_plate *only* when we display/log it
                                last_detected_plate = plate_text
                                # NOTE: last_detection_time was already updated above

                                # --- Perform the actual Database Check and Actions ---
                                if check_database(plate_text):
                                    print("[REGISTERED] ✅ Access Granted!")
                                    lcd_display(plate_text, "Access Granted")
                                    GPIO.output(BUZZ_PIN, GPIO.HIGH)
                                    control_barrier(GPIO.HIGH)      # Open
                                    time.sleep(0.5)                 # Buzzer on duration
                                    GPIO.output(BUZZ_PIN, GPIO.LOW)
                                    time.sleep(4)                   # Barrier open duration << INCREASED?
                                    control_barrier(GPIO.LOW)       # Close
                                    print(f"-> Processed '{plate_text}'. Starting cooldown.")

                                else: # Access Denied
                                    print("[UNREGISTERED] ❌ Access Denied!")
                                    lcd_display(plate_text, "Access Denied")
                                    # Short buzzes for denial
                                    for _ in range(3):
                                        GPIO.output(BUZZ_PIN, GPIO.HIGH)
                                        time.sleep(0.1)
                                        GPIO.output(BUZZ_PIN, GPIO.LOW)
                                        time.sleep(0.1)
                                    time.sleep(1.5) # Show denied message
                                    print(f"-> Processed '{plate_text}'. Starting cooldown.")

                                # === IMPORTANT: Mark plate as processed and record time ===
                                last_processed_plate = plate_text
                                last_process_time = current_time # Start cooldown timer
                                last_detected_plate = "" # Reset last detected to force redisplay if seen again after cooldown

                                # --- Update LCD to Ready after action ---
                                lcd_display("ANPR System", "Ready")
                                time.sleep(0.5) # Small pause before scanning again

                            # Else (condition 3 fail): Plate is new compared to last *processed*,
                            # but same as last *detected* within display debounce time. Do nothing this cycle.
                            # Let OCR stabilize or wait for display debounce timeout.

                        # Else (condition 2 fail): Same plate as last processed. Ignore during cooldown.
                        else:
                             # Optional: Print statement for debugging, can be removed later
                             # if plate_text != last_detected_plate: # Only print if OCR result differs slightly
                             #    print(f"Ignoring '{plate_text}' (matches last processed: '{last_processed_plate}')")
                             #    last_detected_plate = plate_text # Update detected even if ignored
                             pass # Silently ignore

                    # Else (condition 1 fail): Still within the cooldown period after last action.
                    else:
                        # Update last detected plate if it changed slightly, even during cooldown
                        # if plate_text != last_detected_plate:
                        #    last_detected_plate = plate_text
                        pass # Don't process anything, still cooling down

                # Else (OCR returned empty string): No valid text found on the potential plate image.
                # Keep last_detection_time updated from when the *contour* was found? Or only when OCR is non-empty?
                # Let's update only on non-empty OCR (as done above).
                pass

            # --- End of processing extracted plate ---


            # --- Reset Logic: If NO plate contour found for a while, reset the 'processed' lock ---
            if not plate_found:
                # Check if enough time has passed since the last time *any* plate was *detected*
                if current_time - last_detection_time > reset_timeout:
                    if last_processed_plate != "": # Only reset if there's something to reset
                        print(f"\nNo plate detected for {reset_timeout}s. Resetting lock for '{last_processed_plate}'.")
                        last_processed_plate = ""
                        last_detected_plate = "" # Also clear last detected
                        lcd_display("ANPR System", "Ready") # Ensure LCD is Ready
                        # Reset last_detection_time to prevent immediate re-resetting
                        # Set it far in the past, or to current time? Setting to current is simpler.
                        last_detection_time = current_time # Pretend detection just happened for timeout purpose


            # --- Small delay in main loop ---
            time.sleep(0.1) # Main loop sleep


    except KeyboardInterrupt:
        print("\n🛑 Ctrl+C detected. Shutting Down...")
    finally:
        print("Cleaning up resources...")
        # Ensure barrier is closed and buzzer off
        GPIO.output(BARRIER_PIN, GPIO.LOW)
        GPIO.output(BUZZ_PIN, GPIO.LOW)
        lcd_display("System Stopped", "")
        time.sleep(1)
        if lcd_ready:
             try: lcd.clear()
             except Exception: pass
        picam2.stop()
        print("Camera stopped.")
        GPIO.cleanup()
        print("GPIO Cleaned Up. Exiting.")


# --- Initialization Checks ---
if __name__ == "__main__":
    try:
        tesseract_version = pytesseract.get_tesseract_version()
        print(f"Tesseract version: {tesseract_version}")
    except pytesseract.TesseractNotFoundError:
        # (Error message as before) ...
        exit(1)

    try:
        with open('Database.txt', 'r') as f:
             print("Database.txt found.")
    except FileNotFoundError:
         print("[WARNING] Database.txt not found.")
         try:
             with open('Database.txt', 'w') as f: print("  An empty Database.txt created.")
         except IOError as e: print(f"[ERROR] Could not create Database.txt: {e}")

    # --- Start Main Application ---
    main()